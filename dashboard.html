<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mapa de Frota em Tempo Real</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" crossorigin="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap');

    :root {
      color-scheme: light dark;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      --bg-app: #f6f8fb;
      --sidebar-bg: rgba(255, 255, 255, 0.95);
      --sidebar-border: rgba(15, 23, 42, 0.08);
      --accent: #f59f00;
      --text-primary: #0f172a;
      --text-muted: rgba(15, 23, 42, 0.6);
      --glass: rgba(15, 23, 42, 0.08);
      --panel-bg: rgba(255, 255, 255, 0.95);
      --map-bg: #e5e8f0;
      --toggle-bg: rgba(15, 23, 42, 0.05);
      --toggle-color: #0f172a;
      --surface-1: rgba(255, 255, 255, 0.96);
      --surface-2: rgba(255, 255, 255, 0.9);
      --border-strong: rgba(15, 23, 42, 0.12);
      --shadow-strong: 0 24px 40px rgba(5, 10, 25, 0.12);
      font-family: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg-app);
      color: var(--text-primary);
      display: flex;
      transition: background 0.3s ease;
    }

    body.theme-dark {
      --bg-app: radial-gradient(circle at top, #0f172a 0%, #020617 55%, #000 100%);
      --sidebar-bg: rgba(15, 23, 42, 0.92);
      --sidebar-border: rgba(255, 255, 255, 0.08);
      --text-primary: #f9fafb;
      --text-muted: rgba(248, 250, 252, 0.7);
      --glass: rgba(255, 255, 255, 0.12);
      --panel-bg: rgba(15, 23, 42, 0.85);
      --map-bg: #111827;
      --toggle-bg: rgba(255, 255, 255, 0.08);
      --toggle-color: #f9fafb;
      --surface-1: rgba(15, 23, 42, 0.9);
      --surface-2: rgba(15, 23, 42, 0.82);
      --border-strong: rgba(255, 255, 255, 0.12);
      --shadow-strong: 0 24px 50px rgba(0, 0, 0, 0.32);
    }

    @media (prefers-color-scheme: dark) {
      body.theme-auto {
        --bg-app: radial-gradient(circle at top, #0f172a 0%, #020617 55%, #000 100%);
        --sidebar-bg: rgba(15, 23, 42, 0.92);
        --sidebar-border: rgba(255, 255, 255, 0.08);
        --text-primary: #f9fafb;
        --text-muted: rgba(248, 250, 252, 0.7);
        --glass: rgba(255, 255, 255, 0.12);
        --panel-bg: rgba(15, 23, 42, 0.85);
        --map-bg: #111827;
        --toggle-bg: rgba(255, 255, 255, 0.08);
        --toggle-color: #f9fafb;
        --surface-1: rgba(15, 23, 42, 0.9);
        --surface-2: rgba(15, 23, 42, 0.82);
        --border-strong: rgba(255, 255, 255, 0.12);
        --shadow-strong: 0 24px 50px rgba(0, 0, 0, 0.32);
      }
    }

    #app-shell {
      position: relative;
      width: 100%;
      min-height: 100vh;
      background: var(--map-bg);
      overflow: hidden;
    }

	    #sidebar {
	      position: absolute;
	      top: 0;
	      left: 0;
	      bottom: 0;
      width: clamp(220px, 18vw, 280px);
      max-width: 90vw;
      padding: 24px 26px 30px;
      background: var(--sidebar-bg);
      border-right: 1px solid var(--sidebar-border);
      box-shadow: 12px 0 36px rgba(5, 10, 25, 0.18);
	      display: flex;
	      flex-direction: column;
	      gap: 22px;
	      overflow-y: auto;
	      overscroll-behavior: contain;
	      -webkit-overflow-scrolling: touch;
		      z-index: 1500;
	      transition: transform 0.25s ease, opacity 0.25s ease;
	    }

	    .sidebar-header {
	      display: flex;
	      align-items: flex-start;
	      justify-content: space-between;
	      gap: 16px;
	      flex-wrap: wrap;
	    }

	    .sidebar-header > div {
	      padding-left: 56px;
	    }

    .sidebar-header h1 {
      font-size: 1.5rem;
      margin: 0;
    }

	    #sidebar-close,
	    #sidebar-toggle {
	      border: none;
	      border-radius: 50%;
      background: var(--accent);
      color: #0f172a;
      width: 40px;
      height: 40px;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
	      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
	    }

	    #sidebar-close {
	      position: absolute;
	      top: 24px;
	      left: 24px;
		      z-index: 1601;
	    }

    body.theme-dark #sidebar-close,
    body.theme-auto #sidebar-close,
    body.theme-dark #sidebar-toggle,
    body.theme-auto #sidebar-toggle {
      background: rgba(249, 250, 251, 0.92);
      color: #0f172a;
    }

    #sidebar-close:hover,
    #sidebar-toggle:hover {
      transform: scale(1.08);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.25);
      opacity: 0.9;
    }

    #sidebar p {
      margin: 6px 0 0;
      font-size: 0.92rem;
      color: var(--text-muted);
    }

    .sidebar-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .sidebar-section label {
      font-size: 0.82rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }
    #variant-filter-group label {
      color: var(--text-muted);
    }

    .sidebar-section select,
    .sidebar-section input[type="text"] {
      border-radius: 12px;
      border: 1px solid var(--glass);
      padding: 12px 14px;
      font-size: 0.96rem;
      font-weight: 500;
      color: var(--text-primary);
      background: rgba(255, 255, 255, 0.95);
      appearance: none;
      transition: box-shadow 0.2s, border-color 0.2s;
    }

    body.theme-dark .sidebar-section select,
    body.theme-dark .sidebar-section input[type="text"],
    body.theme-auto .sidebar-section select,
    body.theme-auto .sidebar-section input[type="text"] {
      background: rgba(10, 15, 28, 0.8);
      color: #f8fafc;
    }

    .sidebar-section select:focus,
    .sidebar-section input[type="text"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(244, 159, 0, 0.3);
    }

    .sidebar-note {
      font-size: 0.82rem;
      color: var(--text-muted);
      line-height: 1.4;
      border-top: 1px solid var(--glass);
      padding-top: 16px;
    }

    .kpi-floating-context {
      position: absolute;
      top: 56px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 18px;
      border-radius: 999px;
      background: var(--surface-1);
      border: 1px solid var(--border-strong);
      box-shadow: var(--shadow-strong);
      color: var(--text-primary);
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 0.04em;
      z-index: 1003;
      backdrop-filter: blur(12px);
      position: absolute;
      max-width: min(760px, calc(100% - 64px));
      width: fit-content;
    }

    .floating-search {
      position: absolute;
      top: calc(100% + 10px);
      left: 50%;
      transform: translateX(-50%);
      width: min(92vw, 360px);
      background: var(--sidebar-bg);
      border: 1px solid var(--sidebar-border);
      box-shadow: 0 18px 36px rgba(5, 10, 25, 0.2);
      border-radius: 14px;
      padding: 10px 12px;
      display: none;
      z-index: 2200;
      backdrop-filter: blur(10px);
    }
    .floating-search.visible { display: block; }
    .floating-route-input {
      width: 100%;
      box-sizing: border-box;
      border-radius: 12px;
      border: 1px solid var(--border-strong);
      padding: 10px 12px;
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text-primary);
      background: var(--surface-1);
    }
    body.theme-dark .floating-route-input,
    body.theme-auto .floating-route-input {
      background: rgba(10, 15, 28, 0.82);
      color: #f8fafc;
    }
    .floating-route-preview {
      margin-top: 8px;
      max-height: 220px;
      overflow-y: auto;
      display: grid;
      gap: 6px;
    }
    .floating-route-preview .preview-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid var(--border-strong);
      background: var(--surface-2);
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease;
    }
    .floating-route-preview .preview-item:hover { background: rgba(255, 255, 255, 0.14); transform: translateY(-1px); }
    .floating-route-preview .preview-label {
      font-weight: 700;
      color: var(--text-primary);
      font-size: 0.9rem;
    }
    body.theme-dark .floating-route-preview .preview-item {
      border-color: rgba(255, 255, 255, 0.12);
      background: rgba(15, 23, 42, 0.7);
    }
    body.theme-dark .floating-route-preview .preview-item:hover { background: rgba(255, 255, 255, 0.06); }
    @media (min-width: 901px) {
      .floating-search.visible { display: none !important; }
    }
    @media (max-width: 900px) {
      .kpi-floating-context {
        width: min(98vw, 560px);
        padding: 10px 14px;
      }
      .kpi-floating-chip {
        width: 100%;
        justify-content: space-between;
        gap: 12px;
      }
      #kpi-floating-text { flex: 1; text-align: left; }
      #kpi-panel {
        background: var(--surface-1);
        border: 1px solid var(--border-strong);
        box-shadow: var(--shadow-strong);
        padding: 8px;
        width: calc(100% - 16px);
      }
      #kpi-panel .kpi-grid {
        grid-template-columns: repeat(3, minmax(100px, 1fr));
        gap: 4px;
      }
      #kpi-panel .kpi-card {
        background: var(--surface-2);
        border: 1px solid var(--border-strong);
        align-items: flex-start;
        padding: 6px 6px;
      }
      #kpi-panel .kpi-card strong {
        font-size: 1.08rem;
      }
    }

    .kpi-floating-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
      min-width: 0;
      border: none;
      background: transparent;
      color: inherit;
      font: inherit;
      padding: 0;
      cursor: pointer;
    }
    .kpi-floating-chip:focus-visible { outline: 2px solid var(--accent); outline-offset: 3px; }
    .kpi-floating-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.04);
      color: inherit;
      font-size: 0.85rem;
      flex: 0 0 auto;
      flex-shrink: 0;
    }
    body.theme-dark .kpi-floating-icon,
    body.theme-auto .kpi-floating-icon {
      background: rgba(255, 255, 255, 0.08);
    }
    #kpi-floating-text {
      min-width: 0;
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .kpi-floating-clear {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid rgba(15, 23, 42, 0.08);
      background: rgba(15, 23, 42, 0.04);
      color: inherit;
      font-weight: 800;
      line-height: 1;
      padding: 0;
      appearance: none;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, opacity 120ms ease;
      flex: 0 0 auto;
      flex-shrink: 0;
    }
    .kpi-floating-clear:hover { background: rgba(15, 23, 42, 0.12); transform: translateY(-1px); }
    .kpi-floating-clear:active { transform: translateY(0); }
    body.theme-dark .kpi-floating-clear,
    body.theme-auto .kpi-floating-clear {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.18);
    }

    .kpi-panel {
      position: absolute;
      top: 110px;
      left: 50%;
      right: auto;
      transform: translateX(-50%);
      width: min(560px, calc(100% - 36px));
      background: var(--surface-1);
      border-radius: 16px;
      border: 1px solid var(--border-strong);
      padding: 16px;
      box-shadow: var(--shadow-strong);
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 1002;
    }

    .kpi-panel .kpi-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(140px, 1fr));
      gap: 4px;
      justify-items: stretch;
    }

    .kpi-card {
      background: var(--surface-2);
      border-radius: 12px;
      padding: 6px 8px;
      min-height: 68px;
      display: flex;
      flex-direction: column;
      gap: 2px;
      border: 1px solid rgba(15, 23, 42, 0.05);
      align-items: center;
      text-align: center;
      justify-content: center;
    }

	    .kpi-card strong {
	      font-size: 1.4rem;
	      line-height: 1.15;
	      width: 100%;
	    }
	    .kpi-card .kpi-value {
	      font-weight: 800;
	      font-variant-numeric: tabular-nums;
	    }
	    .kpi-card .kpi-speed {
	      display: inline-flex;
	      justify-content: center;
	      align-items: baseline;
	      gap: 4px;
	      white-space: nowrap;
	    }
	    .kpi-card .kpi-speed.has-unit::after {
	      content: "km/h";
	      font-size: 0.72em;
	      font-weight: 700;
	      color: var(--text-muted);
	      opacity: 0.75;
	    }
    .kpi-card .kpi-label,
    .kpi-card .kpi-delta,
    .kpi-card .kpi-meta {
      width: 100%;
    }
    .kpi-card .kpi-meta {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 2px;
    }

	    .kpi-delta {
	      font-size: 0.9rem;
	      letter-spacing: 0;
	      text-transform: none;
	      font-weight: 700;
	      color: var(--text-muted);
	    }
    .kpi-delta.positive {
      color: #10b981;
    }
    .kpi-delta.negative {
      color: #ef4444;
    }
    .kpi-delta.zero {
      color: var(--text-muted);
    }

	    .kpi-label {
	      font-size: 0.7rem;
	      text-transform: lowercase;
	      letter-spacing: 0.02em;
	      color: var(--text-muted);
	    }

    .kpi-meta {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    body.theme-dark .kpi-panel {
      background: rgba(15, 23, 42, 0.88);
    }

    body.theme-dark .kpi-card {
      background: rgba(255, 255, 255, 0.04);
      border-color: rgba(255, 255, 255, 0.08);
    }

    .charts-section {
      margin-top: 12px;
    }
    .charts-section h2 {
      font-size: 1rem;
      margin-bottom: 8px;
      color: var(--text-primary);
    }
    .chart-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }
    .chart-card {
      border-radius: 12px;
      border: 1px solid var(--border-strong);
      background: var(--surface-1);
      padding: 12px;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 8px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      max-width: 320px;
      min-height: 180px;
    }
    .chart-card:hover {
      box-shadow: var(--shadow-strong);
      transform: translateY(-2px);
    }
    .chart-card-header {
      font-weight: 600;
      font-size: 0.95rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .chart-card canvas {
      width: 100% !important;
      height: 104px !important;
      display: block;
    }
	    .chart-card-help {
	      font-size: 1.05rem;
	      font-weight: 700;
	      letter-spacing: 0;
	      text-transform: none;
	      color: var(--text-muted);
	      align-self: flex-end;
	      line-height: 1;
	    }
    .chart-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(6px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 2200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }
    .chart-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
    .chart-overlay-content {
      background: var(--surface-1);
      border-radius: 18px;
      padding: 28px;
      width: min(760px, 95vw);
      max-width: 760px;
      max-height: 85vh;
      overflow: auto;
      box-shadow: var(--shadow-strong);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .chart-overlay h3 {
      margin: 0;
      margin-bottom: 16px;
      font-size: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .chart-overlay-title-main { font-size: 1.2rem; line-height: 1.2; }
    .chart-overlay-context {
      font-size: 0.95rem;
      font-weight: 700;
      color: var(--text-primary);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .chart-overlay canvas {
      width: 100%;
      height: 280px !important;
      display: block;
    }
    .chart-overlay-extra { margin-top: 4px; }
    .overlay-subtitle { margin: 0 0 10px; font-size: 1rem; }
    .overlay-table-wrapper { overflow: auto; border: 1px solid var(--border-strong); border-radius: 10px; background: var(--surface-1); max-height: 320px; }
    .overlay-table { width: 100%; border-collapse: collapse; font-size: 0.92rem; }
    .overlay-table th, .overlay-table td { padding: 8px 10px; text-align: left; border-bottom: 1px solid var(--border-strong); }
    .overlay-table th { background: var(--surface-2); position: sticky; top: 0; z-index: 1; }
    .overlay-table tr:last-child td { border-bottom: none; }
    .overlay-empty { text-align: center; color: var(--text-muted); font-style: italic; }
    .overlay-status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
    .overlay-status-dot.active { background: #2ecc71; box-shadow: 0 0 8px rgba(46, 204, 113, 0.6); }
    .overlay-status-dot.inactive { background: #e74c3c; box-shadow: 0 0 8px rgba(231, 76, 60, 0.6); }
    .chart-overlay-close {
      position: absolute;
      top: 12px;
      right: 12px;
      border: none;
      background: rgba(0, 0, 0, 0.1);
      color: var(--text-primary);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      font-size: 1.1rem;
      cursor: pointer;
    }

    #map-container {
      position: relative;
      height: 100vh;
      width: 100%;
      background: var(--map-bg);
      overflow: hidden;
    }

    #map {
      position: absolute;
      inset: 0;
      height: 100%;
      width: 100%;
      background: var(--map-bg);
    }

    .app-alert {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 16px;
      border-radius: 10px;
      background: var(--surface-1);
      color: var(--text-primary);
      border: 1px solid var(--border-strong);
      box-shadow: var(--shadow-strong);
      z-index: 2300;
      font-weight: 600;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      max-width: min(92vw, 680px);
      text-align: center;
    }

    .app-alert.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ccc;
      transition: background 0.3s;
      flex: 0 0 auto;
    }

    .status-dot.online { background: #2ecc71; box-shadow: 0 0 8px rgba(46, 204, 113, 0.8); }
    .status-dot.fetching { background: #f1c40f; animation: pulse 1s infinite; }
    .status-dot.offline { background: #e74c3c; box-shadow: 0 0 8px rgba(231, 76, 60, 0.7); }

    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.45; } 100% { opacity: 1; } }

    .kpi-active-value {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
    }

    /* Estilos do Popup */
    .custom-popup .leaflet-popup-content-wrapper { padding: 0; overflow: hidden; border-radius: 6px; }
    .custom-popup .leaflet-popup-content { margin: 0; width: 200px !important; }
    
    .pop-header { 
      padding: 10px 12px; 
      color: white; 
      font-weight: bold; 
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      gap: 10px;
    }
    .pop-header__left { display: flex; align-items: center; gap: 8px; min-width: 0; }
    .pop-title { font-size: 0.96rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .pop-header__actions { display: inline-flex; align-items: center; gap: 8px; }
    .pop-body { padding: 12px; font-size: 13px; color: #444; line-height: 1.5; }

    /* MapLibre popup parity */
    .custom-popup .maplibregl-popup-content { padding: 0; margin: 0; width: 220px !important; overflow: hidden; border-radius: 8px; box-shadow: 0 3px 14px rgba(0,0,0,0.2); }
    .custom-popup .maplibregl-popup-tip { display: none; }

    /* Stop popup pills */
    .stop-popup {
      padding: 12px 12px 14px;
      background: rgba(255, 255, 255, 0.98);
    }
    .stop-popup__title {
      font-weight: 800;
      font-size: 0.98rem;
      color: #0f172a;
      line-height: 1.15;
    }
    .stop-popup__meta {
      margin-top: 2px;
      font-size: 0.78rem;
      color: rgba(15, 23, 42, 0.6);
      font-variant-numeric: tabular-nums;
    }
    .stop-popup__section {
      margin-top: 10px;
      font-size: 0.72rem;
      font-weight: 800;
      letter-spacing: 0.02em;
      color: rgba(15, 23, 42, 0.6);
      text-transform: uppercase;
    }
    .pill-row {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .route-preview {
      position: fixed;
      display: grid;
      gap: 6px;
      max-height: 240px;
      overflow-y: auto;
      padding: 8px 10px;
      background: var(--surface-1);
      border-radius: 12px;
      border: 1px solid var(--border-strong);
      box-shadow: var(--shadow-strong);
      z-index: 2200;
    }
    .route-preview.hidden { display: none; }
    .route-preview .preview-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid var(--border-strong);
      background: var(--surface-2);
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease;
    }
    .route-preview .preview-item:hover { background: rgba(255, 255, 255, 0.12); transform: translateY(-1px); }
    .route-preview .preview-label {
      font-weight: 700;
      color: var(--text-primary);
      font-size: 0.9rem;
    }
    body.theme-dark .route-preview .preview-item {
      border-color: rgba(255, 255, 255, 0.12);
      background: rgba(15, 23, 42, 0.7);
    }
    body.theme-dark .route-preview .preview-item:hover { background: rgba(255, 255, 255, 0.06); }
    .route-input-wrapper { position: relative; width: 100%; }
    .route-input-wrapper input {
      width: 100%;
      box-sizing: border-box;
      min-height: 42px;
    }

    /* Ensure sidebar overlays tooltips/popups from the map */
    .leaflet-pane.leaflet-tooltip-pane { z-index: 900 !important; }
    .maplibregl-popup { z-index: 900 !important; }
    .route-selected-pill {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 10px;
      background: var(--surface-1);
      border: 1px solid var(--border-strong);
      box-shadow: var(--shadow-strong);
      cursor: text;
      z-index: 1501;
    }
    .route-selected-pill.hidden { display: none; }
    .route-input-wrapper.pill-visible input {
      opacity: 0;
      pointer-events: none;
    }
    .route-input-wrapper.input-focused .route-selected-pill { display: none; }
    .route-selected-pill #route-selected-text {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      min-width: 0;
      font-weight: 800;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .route-clear {
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 1rem;
      padding: 4px 6px;
      cursor: pointer;
      border-radius: 8px;
      flex-shrink: 0;
      transition: background 120ms ease, transform 120ms ease;
    }
    .route-clear:hover { background: rgba(15, 23, 42, 0.08); transform: translateY(-1px); }
    .route-clear:active { transform: translateY(0px); }
    body.theme-dark .route-clear { color: #f8fafc; }
    .pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.8rem;
      line-height: 1.15;
      font-weight: 800;
      letter-spacing: 0.01em;
      border: 1px solid var(--pill-border, rgba(15, 23, 42, 0.12));
      color: var(--pill-fg, #0b1220);
      background: var(--pill-bg, #e2e8f0);
      white-space: nowrap;
    }
    .pill.pill--clickable {
      cursor: pointer;
      user-select: none;
    }
    .pill--loading {
      background: rgba(148, 163, 184, 0.22);
      border-color: rgba(148, 163, 184, 0.3);
      color: rgba(15, 23, 42, 0.55);
      box-shadow: none;
    }
    body.theme-dark .stop-popup {
      background: rgba(15, 23, 42, 0.92);
    }
    body.theme-dark .stop-popup__title { color: rgba(255,255,255,0.92); }
    body.theme-dark .stop-popup__meta,
    body.theme-dark .stop-popup__section { color: rgba(255,255,255,0.62); }
    body.theme-dark .pill {
      border-color: var(--pill-border, rgba(255,255,255,0.16));
      color: var(--pill-fg, rgba(15, 23, 42, 0.95));
    }

    /* Route/global stops */
    :root {
      --map-zoom-size: 24px;
    }

    @keyframes stopFadeIn {
      from { opacity: 0; transform: scale(0.5); }
      to { opacity: 1; transform: scale(1); }
    }

    .stop-marker {
      --stop-border: #f1c40f; /* strong yellow */
      --stop-fill: rgba(255, 255, 255, 0.98);
      --stop-arrow: var(--stop-border);
      --stop-ang: 0deg;
      --stop-size: var(--map-zoom-size, 24px);
      --stop-border-w: clamp(3px, calc(var(--stop-size) * 0.16), 6px);
      --stop-arrow-l: clamp(8px, calc(var(--stop-size) * 0.42), 13px);
      --stop-arrow-h: clamp(3px, calc(var(--stop-size) * 0.16), 6px);
      width: var(--stop-size);
      height: var(--stop-size);
      border-radius: 50%;
      background: var(--stop-fill);
      border: var(--stop-border-w) solid var(--stop-border);
      box-shadow: 0 10px 24px rgba(0,0,0,0.28);
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.35));
      position: relative;
      opacity: 1;
      transform: scale(1);
      transform-origin: center;
      will-change: transform, opacity, filter;
      animation: none;
      transition: opacity 320ms ease, transform 360ms cubic-bezier(0.2, 0.9, 0.2, 1), filter 220ms ease;
    }
    .stop-marker.stop--hidden {
      opacity: 0;
      transform: scale(0.78);
      animation: none;
    }
    .stop-marker.stop--shown {
      opacity: 1;
      transform: scale(1);
      animation: none;
    }

    /* Contentores das mini-pills sobre as paragens */
    .stop-label-container {
      pointer-events: none; /* Permite clicar na paragem por baixo */
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      opacity: 0;
      transform: translateY(6px) scale(0.94);
      transition: opacity 260ms ease, transform 320ms cubic-bezier(0.22, 1, 0.36, 1);
    }
    .stop-label-container.stop-label--shown {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    .stop-label-container.stop-label--hidden {
      opacity: 0;
      transform: translateY(10px) scale(0.92);
    }

    .stop-label-pills {
      display: flex;
      gap: 2px;
      justify-content: center;
      flex-wrap: wrap;
      max-width: 60px; /* Mant√©m as pills compactas */
      opacity: 0;
      transform: translateY(6px) scale(0.94);
      transition: opacity 240ms ease, transform 280ms cubic-bezier(0.2, 0.9, 0.2, 1);
      will-change: opacity, transform;
    }
    .stop-label-pills.stop-label-pills--visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .stop-label-pill-mini {
      padding: 1px 3px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: 900;
      line-height: 1;
      color: white;
      border: 1px solid rgba(0,0,0,0.15);
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
      white-space: nowrap;
      text-shadow: 0 0.5px 1px rgba(0,0,0,0.3);
    }
    body.theme-dark .stop-label-pill,
    body.theme-auto .stop-label-pill {
      background: rgba(15, 23, 42, 0.92);
      color: #f8fafc;
      border-color: rgba(248, 250, 252, 0.12);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.32);
    }
    body.theme-dark .stop-label-pill__pill,
    body.theme-auto .stop-label-pill__pill {
      border-color: var(--pill-border, rgba(248, 250, 252, 0.16));
      box-shadow: none;
    }
    body.stop-labels-visible .stop-label-pill {
      opacity: 1;
      transform: translate(-50%, -2px) scale(1);
    }
    .stop-marker .stop-arrow {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      transform: translate(-50%, -50%) rotate(var(--stop-ang)) translateX(calc(var(--stop-arrow-l) + 1px));
      border-left: var(--stop-arrow-l) solid var(--stop-arrow);
      border-top: var(--stop-arrow-h) solid transparent;
      border-bottom: var(--stop-arrow-h) solid transparent;
      opacity: 0.95;
    }

    /* Leaflet wrapper class so marker appearance changes don't animate map pan/zoom transforms */
    .leaflet-marker-icon.stop-fade {
      will-change: opacity, transform;
    }
    .leaflet-marker-icon.stop-fade {
      width: var(--map-zoom-size, 24px) !important;
      height: var(--map-zoom-size, 24px) !important;
      margin-left: calc(var(--map-zoom-size, 24px) / -2) !important;
      margin-top: calc(var(--map-zoom-size, 24px) / -2) !important;
    }

    /* Modern route pills for stop popups */
    .route-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 9px;
      border-radius: 999px;
      font-size: 0.8rem;
      line-height: 1.15;
      font-weight: 900;
      letter-spacing: 0.01em;
      border: 1px solid var(--pill-border, rgba(15, 23, 42, 0.12));
      color: var(--pill-fg, #0b1220);
      background: var(--pill-bg, #e2e8f0);
      white-space: nowrap;
      user-select: none;
      box-shadow: 0 6px 12px rgba(15, 23, 42, 0.12);
      transition: transform 160ms ease, filter 160ms ease;
    }
    .route-pill.route-pill--clickable { cursor: pointer; }
    .route-pill.route-pill--clickable:hover { filter: brightness(0.98); transform: translateY(-1px); }
    .route-pill.route-pill--clickable:active { transform: translateY(0px); filter: brightness(0.96); }
    .route-pill.route-pill--loading {
      background: rgba(148, 163, 184, 0.22);
      border-color: rgba(148, 163, 184, 0.3);
      color: rgba(15, 23, 42, 0.55);
      box-shadow: none;
    }
    .route-pill.route-pill--inline {
      box-shadow: none;
      padding: 4px 10px;
      font-size: 0.92rem;
      vertical-align: middle;
    }
    .route-title-rest {
      font-weight: 700;
      color: var(--text-primary);
      vertical-align: middle;
    }
    body.theme-dark .route-pill {
      border-color: var(--pill-border, rgba(255, 255, 255, 0.16));
      color: var(--pill-fg, #0b1220);
      box-shadow: none;
    }
    .custom-popup .maplibregl-popup-close-button { color: white; font-size: 16px; padding: 6px 10px; z-index: 10; }
    .custom-popup .maplibregl-popup-close-button:hover { background: rgba(0,0,0,0.1); }

    /* Leaflet Tooltips (√≠cones) */
    .veh-label {
      background: transparent;
      border: none;
      box-shadow: none;
      color: #333;
      font-size: 16px;
      font-weight: 700;
      transform: translate(-50%, -50%);
      pointer-events: none !important;
    }

    .veh-wrapper {
      width: 34px;
      height: 42px;
    }

    .veh-marker {
      position: relative;
      width: 34px;
      height: 42px;
      transform: translate3d(0, 0, 0);
      --c: #2ecc71;
    }

    /* Smooth marker slide on new pings (only when we opt-in via JS). */
    .leaflet-marker-icon.veh-animating,
    .maplibregl-marker.veh-animating,
    .veh-wrapper.veh-animating {
      will-change: transform;
      transition: transform var(--veh-move-ms, 1000ms) linear;
    }

    /* Never animate marker transforms while the user is interacting with the map (pan/zoom),
       otherwise markers can "drift" a few pixels due to the map engine updating transforms. */
    .map-interacting .leaflet-marker-icon,
    .map-interacting .maplibregl-marker,
    .map-interacting .veh-wrapper,
    .map-interacting .stop-marker,
    .map-interacting .veh-marker {
      transition: none !important;
    }
    .map-interacting .stop-marker {
      animation: none !important;
    }

    @media (prefers-reduced-motion: reduce) {
      .leaflet-marker-icon.veh-animating,
      .maplibregl-marker.veh-animating {
        transition: none !important;
      }
    }

    .veh-pin {
      position: absolute;
      left: 50%;
      top: 2px;
      width: 28px;
      height: 28px;
      background: var(--c);
      border-radius: 50% 50% 50% 0;
      transform: translateX(-50%) rotate(-45deg);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.9);
    }

    .veh-pin::after {
      content: "";
      position: absolute;
      width: 16px;
      height: 16px;
      top: 5px;
      left: 5px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 50%;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.12);
    }

    .veh-icon {
      position: absolute;
      left: 50%;
      top: 8px;
      transform: translateX(-50%);
      font-size: 14px;
      color: rgba(26, 26, 26, 0.92);
      text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
      pointer-events: none;
    }

    .veh--stale {
      filter: grayscale(1) saturate(0.2);
      opacity: 0.55;
    }

    .veh--inactive {
      opacity: 0;
    }

    .veh--faded {
      opacity: 0.25;
      filter: grayscale(1) saturate(0.1);
    }

    .veh--hl {
      opacity: 1;
    }

	    #sidebar-toggle {
	      position: absolute;
	      top: 24px;
	      left: 24px;
      z-index: 1600;
      opacity: 0;
      pointer-events: none;
    }

    body.sidebar-collapsed #sidebar {
      transform: translateX(-105%);
      opacity: 0;
      pointer-events: none;
    }

    body.sidebar-collapsed #sidebar-toggle {
      opacity: 1;
      pointer-events: auto;
    }

    .hidden {
      display: none !important;
    }

    /* Keep popups above everything */
    .leaflet-pane.leaflet-popup-pane { z-index: 4000 !important; }
    .maplibregl-popup { z-index: 4000 !important; }

	    @media (max-width: 900px) {
	      #sidebar {
	        position: fixed;
	        width: min(88vw, 340px);
	        max-width: 88vw;
	        border-radius: 0;
	      }

	      .sidebar-header h1 {
	        font-size: 1.3rem;
	      }

	      .charts-section h2 {
	        font-size: 0.95rem;
	      }

	      .chart-grid {
	        grid-template-columns: 1fr;
	      }

	      .chart-card {
	        max-width: none;
	        min-height: 170px;
	        touch-action: manipulation;
	      }

	      #map-container {
	        height: 100dvh;
	      }

      .kpi-floating-context {
        font-size: 0.9rem;
        top: calc(62px + env(safe-area-inset-top));
      }

      #kpi-panel {
        top: calc(114px + env(safe-area-inset-top));
        width: calc(100% - 16px);
        padding: 8px;
        gap: 8px;
        border-radius: 14px;
      }

      #kpi-panel .kpi-grid {
        grid-template-columns: repeat(3, minmax(100px, 1fr));
        gap: 4px;
      }

	      #kpi-panel .kpi-card {
	        min-height: 58px;
	        padding: 5px 6px;
	      }

	      #kpi-panel .kpi-card strong {
	        font-size: 1.08rem;
	      }

	      #kpi-panel .kpi-label {
	        font-size: 0.64rem;
	      }

	      #kpi-panel .status-dot {
	        width: 10px;
	        height: 10px;
	      }

		      #sidebar-toggle,
		      #sidebar-close {
		        top: calc(12px + env(safe-area-inset-top));
		        left: calc(12px + env(safe-area-inset-left));
		      }

		      body:not(.sidebar-collapsed) .kpi-panel,
		      body:not(.sidebar-collapsed) .kpi-floating-context {
		        opacity: 0;
		        pointer-events: none;
		      }
		    }
		  </style>
</head>
<body class="theme-auto">
  <div id="app-shell">
	    <aside id="sidebar">
	      <button id="sidebar-close" type="button" aria-label="Fechar filtros">‚úï</button>
	      <div class="sidebar-header">
	        <div>
	          <h1>üöå Dashboard Carris</h1>
	          <p>Feito por Abelhato</p>
	        </div>
	      </div>
      <div class="sidebar-section">
        <label for="category-filter">üóÇÔ∏è Categoria</label>
        <select id="category-filter"></select>
      </div>
      <div class="sidebar-section">
        <label for="route-filter">üõ£Ô∏è Carreira</label>
        <div class="route-input-wrapper">
          <input id="route-filter" type="text" placeholder="Pesquise por carreira..." autocomplete="off">
          <div id="route-selected-pill" class="route-selected-pill hidden" role="button" tabindex="0" aria-label="Carreira selecionada">
            <span id="route-selected-text"></span>
            <button id="route-clear" class="route-clear" type="button" aria-label="Voltar √† Rede Global">‚úï</button>
          </div>
        </div>
        <datalist id="route-filter-options"></datalist>
        <div id="route-preview" class="route-preview hidden" role="listbox" aria-label="Sugest√µes de carreiras"></div>
      </div>
      <div class="sidebar-section hidden" id="variant-filter-group">
        <label for="variant-filter">üîÄ Variante</label>
        <select id="variant-filter"></select>
      </div>
      <section class="charts-section" aria-label="Tend√™ncias da frota">
        <h2>üìà Tend√™ncias r√°pidas</h2>
        <div class="chart-grid">
	          <button class="chart-card" id="chart-speed-card" type="button">
	            <div class="chart-card-header">
	              <span>Velocidade Comercial</span>
	            </div>
	            <canvas id="chart-speed-preview"></canvas>
	            <span class="chart-card-help" aria-hidden="true">‚§¢</span>
	          </button>
	          <button class="chart-card" id="chart-volume-card" type="button">
	            <div class="chart-card-header">
	              <span>Volume da Frota</span>
	            </div>
	            <canvas id="chart-volume-preview"></canvas>
	            <span class="chart-card-help" aria-hidden="true">‚§¢</span>
	          </button>
        </div>
      </section>
      <p class="sidebar-note">
      </p>
    </aside>
    <div id="map-container">
      <div class="kpi-floating-context" id="kpi-floating-context">
        <div id="kpi-floating-chip" class="kpi-floating-chip" role="button" tabindex="0" aria-label="Pesquisar carreira">
          <span class="kpi-floating-icon" aria-hidden="true"><i class="fa fa-search"></i></span>
          <span id="kpi-floating-text">Rede Global</span>
          <button id="kpi-floating-clear" class="kpi-floating-clear hidden" type="button" aria-label="Voltar √† Rede Global" title="Voltar √† Rede Global">‚úï</button>
        </div>
        <div id="floating-search" class="floating-search hidden" aria-label="Pesquisar carreira (mobile)">
          <input id="floating-route-input" class="floating-route-input" type="text" placeholder="Pesquise por carreira..." autocomplete="off">
          <div id="floating-route-preview" class="floating-route-preview"></div>
        </div>
      </div>
      <div class="kpi-panel" id="kpi-panel">
        <div class="kpi-grid">
          <article class="kpi-card">
            <span class="kpi-label">Ve√≠culos ativos</span>
            <strong class="kpi-value kpi-active-value">
              <span id="status-dot" class="status-dot" aria-hidden="true"></span>
              <span id="kpi-active-vehicles">‚Äî</span>
            </strong>
            <span class="kpi-meta" id="kpi-last-update">‚Äî</span>
          </article>
	          <article class="kpi-card">
	            <span class="kpi-label">Vel. comercial</span>
	            <strong class="kpi-value kpi-speed" id="kpi-vel-day">‚Äî</strong>
	          </article>
	          <article class="kpi-card">
	            <span class="kpi-label">Vel. comercial (1 hora)</span>
	            <strong class="kpi-value kpi-speed" id="kpi-vel-hour">‚Äî</strong>
	            <span class="kpi-delta" id="kpi-vel-hour-delta">‚Äî</span>
	          </article>
        </div>
      </div>
      <button id="sidebar-toggle" type="button" aria-controls="sidebar" aria-expanded="false" aria-label="Mostrar filtros">‚ò∞</button>
      <div id="map"></div>
      <div class="app-alert" id="app-alert" role="status" aria-live="polite"></div>
      <div class="chart-overlay" id="chart-overlay" role="dialog" aria-modal="true" aria-label="Gr√°fico ampliado">
        <div class="chart-overlay-content">
          <button class="chart-overlay-close" id="chart-overlay-close" type="button" aria-label="Fechar gr√°fico ampliado">‚úï</button>
          <h3 id="chart-overlay-title">Velocidade Comercial</h3>
          <canvas id="chart-overlay-canvas"></canvas>
          <div class="chart-overlay-extra" id="chart-overlay-extra" hidden>
            <h4 class="overlay-subtitle">Ve√≠culos detetados</h4>
            <div class="overlay-table-wrapper">
              <table class="overlay-table">
                <thead>
                  <tr>
                    <th>Ve√≠culo</th>
                    <th>Modelo</th>
                    <th>Primeiro ping</th>
                    <th>√öltimo ping</th>
                    <th>Dist√¢ncia (km)</th>
                    <th>Viagens</th>
                    <th>Estado</th>
                  </tr>
                </thead>
                <tbody id="overlay-vehicle-rows">
                  <tr><td colspan="7" class="overlay-empty">A carregar‚Ä¶</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
	    const API_URL = "https://rt.jdcp.workers.dev/";
	    const urlParams = new URLSearchParams(window.location.search);
	    const ACTIVE_WINDOW_MIN = (() => {
	      const raw = (urlParams.get("active_window_min") || urlParams.get("activeWindowMin") || "").trim();
	      if (!raw) return 10;
	      const parsed = Number.parseInt(raw, 10);
	      if (!Number.isFinite(parsed)) return 10;
	      return Math.max(1, Math.min(180, parsed));
	    })();

	    const MAP_CENTER = [38.736946, -9.142685];
	    const MAP_ZOOM = 13;
	    const REFRESH_RATE_MS = 5000;
    // Mimic Streamlit dashboard: on each poll, vehicles with a new ping slide for ~1s, otherwise stay still.
    const ANIMATION_MS = 1000;
    const ACTIVE_SECONDS = 300;
    const INACTIVE_SECONDS = 600;

    const SHAPES_MOCK = {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {"linha": "727"},
          "geometry": {
            "type": "LineString",
            "coordinates": [[-9.142, 38.736], [-9.145, 38.740], [-9.150, 38.735]]
          }
        }
      ]
    };

    const VEHICLES_MOCK = [
      { id: "2401", lat: 38.7369, lon: -9.1426, linha: "727", bearing: 45, speed: 22, category: "Bus", ts: Date.now() },
      { id: "305",  lat: 38.7100, lon: -9.1300, linha: "28E", bearing: 180, speed: 12, category: "El√©tricos", ts: Date.now() },
      { id: "1001", lat: 38.7600, lon: -9.1600, linha: "201", bearing: 90, speed: 30, category: "Madrugada", ts: Date.now() }
    ];

    const OFFLINE_VEHICLES_URL = new URL("static/veiculos.json", location.href).href;
    let offlineVehiclesCache = null;

    const ROUTE_TRANSLATOR_URL = new URL("tradutor_rotas.csv", location.href).href;
    const ROUTES_DATA_URL = new URL("routes.txt", location.href).href;
    const ROUTE_TRANSLATOR = { byId: {}, base: {} };
    const CATEGORY_FILTER_ALL = "__ALL_CATEGORIES__";
    const ROUTE_FILTER_ALL = "__ALL_ROUTES__";
    const VARIANT_FILTER_ALL = "__ALL_VARIANTS__";
    const ROUTE_GLOBAL_LABEL = "üåê Rede Completa";
    const STANDARD_ROUTE_CATEGORIES = [
      "Autocarros Diurnos",
      "Carreiras de Bairro",
      "El√©tricos",
      "Rede Madrugada"
    ];
    // Zone mapping provided by Carris (for future zoning features).
    const ZONE_COLOR_BY_NAME = {
      Bairro: "#FFE113",
      Centro: "#FF7F00",
      Ocidental: "#FF0078",
      Madrugada: "#0060A9",
      Transversal: "#808080",
      Oriental: "#F70002",
      Noroeste: "#00A0EF",
      Norte: "#39BA2E"
    };
    const ZONE_ROUTE_BASES = {
      Centro: new Set([
        "12E", "24E", "25E", "28E", "51E", "52E", "53E", "54E", "55E",
        "702", "706", "709", "712", "713", "730", "734", "737", "740",
        "773", "774", "790", "797"
      ]),
      Ocidental: new Set([
        "15E", "18E", "714", "723", "732", "748", "751", "760", "776",
        "784", "786"
      ]),
      Madrugada: new Set([
        "201", "202", "203", "204", "205", "206", "207", "208", "209", "210"
      ]),
      Transversal: new Set([
        "701", "703", "720", "727", "728", "728F", "738", "742", "750", "752",
        "753", "756", "767"
      ]),
      Oriental: new Set([
        "16E", "705", "708", "718", "722", "725", "731", "744", "745", "749",
        "755", "759", "779", "781", "782", "783", "793", "794"
      ]),
      Noroeste: new Set([
        "711", "716", "724", "726", "729", "746", "754", "758", "763", "764",
        "765", "768", "770", "771", "780", "799"
      ]),
      Norte: new Set([
        "717", "735", "736", "747", "757", "777", "778", "796", "798"
      ])
    };

    function dedupeList(list) {
      const seen = new Set();
      return list
        .map(item => (item || "").trim())
        .filter(item => {
          if (!item) return false;
          const key = item.toLowerCase();
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
    }

	    function normalizeBaseUrl(raw) {
	      if (!raw) return null;
	      const value = raw.trim();
	      if (!value) return null;
	      const proto = (typeof location !== "undefined" && location.protocol && location.protocol !== "file:") ? location.protocol : "http:";
	      const host = (typeof location !== "undefined" && location.hostname) ? location.hostname : "127.0.0.1";
	      if (/^\d+$/.test(value)) return `${proto}//${host}:${value}`;
	      if (/^[\w.-]+:\d+$/i.test(value)) return `${proto}//${value}`;
	      if (/^https?:\/\//i.test(value)) return value;
	      return null;
	    }

	    function resolveBackendBases() {
	      const bases = ["https://tyron-uncondensational-prepossessingly.ngrok-free.dev"];
	      const override = urlParams.get("backend") || urlParams.get("api_base");
	      const normalizedOverride = normalizeBaseUrl(override);
	      if (normalizedOverride) bases.push(normalizedOverride);
	      const originOk = typeof location !== "undefined" && location.origin && location.origin !== "null" && location.protocol !== "file:";
	      const hostname = originOk ? location.hostname : "";
	      const proto = originOk ? location.protocol : "http:";
	      const isLoopback = hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";

	      // Prefer same-origin first (works when dashboard is served by the API itself,
	      // or when a reverse proxy exposes both dashboard+API on the same public port).
	      if (originOk && hostname) {
	        bases.push(location.origin);
	        // When the page is opened from a non-loopback host (e.g. mobile accessing http://192.168.x.x:8000),
	        // 127.0.0.1 would point to the phone itself. Try the same hostname with our known API ports.
	        bases.push(`${proto}//${hostname}:8002`, `${proto}//${hostname}:8001`);
	      }

	      // Local development fallback (only when the browser is actually on loopback).
	      if (isLoopback) {
	        bases.push("http://127.0.0.1:8002", "http://127.0.0.1:8001");
	      }

	      return dedupeList(bases);
	    }

    const BACKEND_BASES = resolveBackendBases();
    const KPI_BASE_URLS = BACKEND_BASES.length ? BACKEND_BASES : ["http://127.0.0.1:8001", "http://127.0.0.1:8002"];
    const KPI_CATEGORIES_PATH = "/api/kpis/categorias";
    const KPI_ENDPOINTS = {
      categories: KPI_BASE_URLS.map(base => `${base}${KPI_CATEGORIES_PATH}`),
      routeLegacy: KPI_BASE_URLS.map(base => `${base}/api/kpis`),
      route: KPI_BASE_URLS.map(base => `${base}/api/kpis/route`),
      routeVariant: KPI_BASE_URLS.map(base => `${base}/api/kpis/route_variant`),
      category: KPI_BASE_URLS.map(base => `${base}/api/kpis/category`)
    };
    const KPI_CACHE_TTL_MS = 25_000;
    const KPI_REFRESH_INTERVAL_MS = 30_000;
    const CHART_PATHS = ["/historico/metricas/resumo", "/historico/metricas"];
    const CHARTS_ENDPOINTS = KPI_BASE_URLS.flatMap(base => CHART_PATHS.map(path => `${base}${path}`));
    const LOCAL_BACKENDS = BACKEND_BASES.length ? BACKEND_BASES : ["http://127.0.0.1:8001", "http://127.0.0.1:8002"];
    // Prefer the upstream realtime GTFS-RT feed for fresher vehicle positions, then fall back to local snapshots.
    const VEHICLE_ENDPOINTS = dedupeList([
      API_URL,
      ...LOCAL_BACKENDS.flatMap(base => ["/api/frota", "/api/json", "/api/vehicles"].map(path => `${base}${path}`)),
    ]);
    const CHARTS_CACHE_TTL_MS = 60_000;
    const CHARTS_MIN_INTERVAL_MS = 35_000;
    const CHARTS_REFRESH_INTERVAL_MS = 45_000;
    const CHARTS_DETAIL_PATH = "/historico/metricas";
    const CHARTS_DETAIL_ENDPOINTS = KPI_BASE_URLS.map(base => `${base}${CHARTS_DETAIL_PATH}`);
    const HEALTH_ENDPOINTS = KPI_BASE_URLS.map(base => `${base}/health`);

    let selectedCategory = CATEGORY_FILTER_ALL;
    let selectedRoute = ROUTE_FILTER_ALL;
    let selectedVariant = VARIANT_FILTER_ALL;
    let lastVehicles = [];
    const routeOptions = new Map(); // baseId -> { label: string, variants: Map<variantId, label>, categories: Set<string> }
    const ROUTE_DETAILS = new Map(); // routeId -> { shortName, longName }
    const BASE_ROUTE_DETAILS = new Map(); // baseId -> { shortName, longName }
    let routesCatalogLoaded = false;

    const categorySelect = document.getElementById("category-filter");
    const routeInput = document.getElementById("route-filter");
    const routeDatalist = document.getElementById("route-filter-options");
    const routePreview = document.getElementById("route-preview");
    const routeClear = document.getElementById("route-clear");
    const routeSelectedPill = document.getElementById("route-selected-pill");
    const routeSelectedText = document.getElementById("route-selected-text");
    const routeInputWrapper = document.querySelector(".route-input-wrapper");
    const variantSelect = document.getElementById("variant-filter");
    const variantGroup = document.getElementById("variant-filter-group");
    const statusDot = document.getElementById("status-dot");
    const sidebarToggle = document.getElementById("sidebar-toggle");
    const sidebarClose = document.getElementById("sidebar-close");
    const routeLabelById = new Map();
    const routeLabelLookup = new Map();
    const kpiPanel = document.getElementById("kpi-panel");
    const kpiLastUpdate = document.getElementById("kpi-last-update");
    const kpiActiveVehicles = document.getElementById("kpi-active-vehicles");
    const kpiVelDay = document.getElementById("kpi-vel-day");
    const kpiVelHour = document.getElementById("kpi-vel-hour");
    const kpiContext = document.getElementById("kpi-context");
    const kpiFloatingText = document.getElementById("kpi-floating-text");
    const kpiFloatingChip = document.getElementById("kpi-floating-chip");
    const kpiFloatingClear = document.getElementById("kpi-floating-clear");
    const kpiVelHourDelta = document.getElementById("kpi-vel-hour-delta");
    const appAlert = document.getElementById("app-alert");
    const chartSpeedCard = document.getElementById("chart-speed-card");
    const chartVolumeCard = document.getElementById("chart-volume-card");
    const chartSpeedCanvas = document.getElementById("chart-speed-preview");
    const chartVolumeCanvas = document.getElementById("chart-volume-preview");
    const chartOverlay = document.getElementById("chart-overlay");
    const chartOverlayTitle = document.getElementById("chart-overlay-title");
    const chartOverlayExtra = document.getElementById("chart-overlay-extra");
    const chartOverlayVehicleRows = document.getElementById("overlay-vehicle-rows");
    const chartOverlayCanvas = document.getElementById("chart-overlay-canvas");
    const floatingSearch = document.getElementById("floating-search");
    const floatingRouteInput = document.getElementById("floating-route-input");
    const floatingRoutePreview = document.getElementById("floating-route-preview");
    const chartOverlayClose = document.getElementById("chart-overlay-close");
    let sidebarCollapsed = false;
    let categoryKpisCache = { timestamp: 0, data: [] };
    let routeKpisCache = { timestamp: 0, key: "", row: null };
    let lastKpiTimestamp = null;
    let kpiAgeTimer = null;
    let chartRefreshIntervalId = null;
    let chartCache = { paramsKey: "", timestamp: 0, summary: null, lineCandidate: null };
    let lastChartFetchTs = 0;
    let trendTimeline = [];
    let previewCharts = { speed: null, volume: null };
    let overlayChartInstance = null;
    let currentOverlayType = null;
    let lastTrendSummary = { timeline: [], kpi: null, rows: [], lineCandidate: null };
    let lastTrendLineCandidate = null;
    const timeLabelFormatter = new Intl.DateTimeFormat("pt-PT", {
      hour: "2-digit",
      minute: "2-digit",
    });

    function showAppError(message) {
      if (!appAlert) return;
      appAlert.textContent = message;
      appAlert.classList.add("visible");
    }

    function clearAppError() {
      if (!appAlert) return;
      appAlert.classList.remove("visible");
    }

    window.addEventListener("error", event => {
      showAppError(`Erro inesperado: ${event.message}`);
    });
    window.addEventListener("unhandledrejection", event => {
      showAppError(`Erro de promessa: ${event.reason}`);
    });

    function parseTranslatorCsv(text) {
      const byId = {};
      const base = {};
      if (!text) return { byId, base };
      const clean = text.replace(/\r/g, "\n");
      const lines = clean.split("\n");
      for (let i = 1; i < lines.length; i += 1) {
        const line = lines[i].trim();
        if (!line) continue;
        const parts = line.split(/,(.+)/);
        if (parts.length < 2) continue;
        const rawId = parts[0].replace(/^\ufeff/, "").trim();
        const name = parts[1].trim();
        if (!rawId || !name) continue;
        byId[rawId] = name;
        const baseKey = rawId.split("_")[0] || rawId;
        if (baseKey && !base[baseKey]) base[baseKey] = name;
      }
      return { byId, base };
    }

    async function loadRouteTranslator() {
      try {
        const resp = await fetch(ROUTE_TRANSLATOR_URL, { cache: "no-store" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const text = await resp.text();
        const parsed = parseTranslatorCsv(text);
        ROUTE_TRANSLATOR.byId = parsed.byId;
        ROUTE_TRANSLATOR.base = parsed.base;
        refreshRouteLabels();
        refreshRouteTaxonomy();
      } catch (err) {
        console.warn("Falha ao carregar tradutor de rotas:", err);
      }
    }

    async function loadRoutesCatalog() {
      if (routesCatalogLoaded) return;
      try {
        const resp = await fetch(ROUTES_DATA_URL, { cache: "no-store" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const text = await resp.text();
        const lines = text.replace(/\r/g, "\n").split("\n");
        if (!lines.length) return;
        const header = splitCsvLine(lines[0]).map(h => h.replace(/^\ufeff/, "").trim());
        const idxRouteId = header.indexOf("route_id");
        const idxShort = header.indexOf("route_short_name");
        const idxLong = header.indexOf("route_long_name");
        let dirty = false;
        const getPart = (parts, idx) => {
          if (idx < 0 || idx >= parts.length) return "";
          return parts[idx] || "";
        };
        for (let i = 1; i < lines.length; i += 1) {
          const rawLine = lines[i];
          if (!rawLine || !rawLine.trim()) continue;
          const parts = splitCsvLine(rawLine);
          const routeId = getPart(parts, idxRouteId).trim();
          if (!routeId) continue;
          const shortName = getPart(parts, idxShort).trim();
          const longName = getPart(parts, idxLong).trim();
          const baseId = getBaseRouteKey(routeId);
          if (!baseId) continue;
          if (registerRoute(baseId, routeId, { shortName, longName })) dirty = true;
        }
        routesCatalogLoaded = true;
        if (dirty) {
          rebuildRouteSuggestions();
          updateVariantOptions();
          refreshRouteTaxonomy();
        }
      } catch (err) {
        console.warn("Falha ao carregar routes.txt:", err);
      }
    }

    function splitCsvLine(line) {
      const result = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i += 1) {
        const char = line[i];
        if (char === '"' && line[i + 1] === '"') {
          current += '"';
          i += 1;
          continue;
        }
        if (char === '"') {
          inQuotes = !inQuotes;
          continue;
        }
        if (char === ',' && !inQuotes) {
          result.push(current);
          current = "";
          continue;
        }
        current += char;
      }
      result.push(current);
      return result;
    }

    function rememberRouteMeta(routeId, shortName, longName) {
      if (!routeId) return;
      const shortClean = (shortName || "").trim();
      const longClean = (longName || "").trim();
      if (!shortClean && !longClean) return;
      ROUTE_DETAILS.set(routeId, { shortName: shortClean, longName: longClean });
      const base = getBaseRouteKey(routeId);
      if (!base) return;
      const existing = BASE_ROUTE_DETAILS.get(base) || {};
      let updated = false;
      if (shortClean && !existing.shortName) {
        existing.shortName = shortClean;
        updated = true;
      }
      if (longClean && !existing.longName) {
        existing.longName = longClean;
        updated = true;
      }
      if (updated || !BASE_ROUTE_DETAILS.has(base)) {
        BASE_ROUTE_DETAILS.set(base, existing);
      }
    }

    function ensureRouteEntry(baseId) {
      if (!baseId) return null;
      let entry = routeOptions.get(baseId);
      let created = false;
      if (!entry) {
        entry = { label: "", variants: new Map(), categories: new Set(), zones: new Set() };
        routeOptions.set(baseId, entry);
        created = true;
      } else {
        if (!entry.variants) entry.variants = new Map();
        if (!entry.categories) entry.categories = new Set();
        if (!entry.zones) entry.zones = new Set();
      }
      return { entry, created };
    }

    function registerRoute(baseId, variantId, options = {}) {
      if (!baseId) return false;
      const { shortName, longName, label, category } = options;
      if (shortName || longName) {
        rememberRouteMeta(variantId || baseId, shortName, longName);
      }
      const fallbackLabel = label || shortName || longName || translateRoute(variantId) || translateRoute(baseId) || variantId || baseId;
      const ensured = ensureRouteEntry(baseId);
      if (!ensured) return false;
      const { entry, created } = ensured;
      let dirty = created;
      const baseLabel = formatRouteLabel(baseId, fallbackLabel);
      if (entry.label !== baseLabel) {
        entry.label = baseLabel;
        dirty = true;
      }
      if (variantId && variantId !== baseId) {
        const variantLabel = formatVariantLabel(variantId, fallbackLabel);
        const normalizedVariant = (variantLabel || "").trim();
        if (normalizedVariant && (!entry.variants.has(variantId) || entry.variants.get(variantId) !== normalizedVariant)) {
          entry.variants.set(variantId, normalizedVariant);
          dirty = true;
        }
      }
      const resolvedCategory = category || definirCategoria(shortName || fallbackLabel || baseId);
      const baseCategory = definirCategoria(baseId);
      const nextCategories = new Set([resolvedCategory, baseCategory].filter(Boolean));
      const categoriesChanged =
        !entry.categories ||
        entry.categories.size !== nextCategories.size ||
        Array.from(nextCategories).some(cat => !entry.categories.has(cat));
      if (categoriesChanged) {
        entry.categories = nextCategories;
        dirty = true;
      }
      const resolvedZone = definirZona(shortName || fallbackLabel || baseId);
      const nextZones = new Set(resolvedZone ? [resolvedZone] : []);
      const zonesChanged =
        !entry.zones ||
        entry.zones.size !== nextZones.size ||
        Array.from(nextZones).some(zone => !entry.zones.has(zone));
      if (zonesChanged) {
        entry.zones = nextZones;
        dirty = true;
      }
      return dirty;
    }

    function setSidebarCollapsed(collapsed) {
      sidebarCollapsed = Boolean(collapsed);
      document.body.classList.toggle("sidebar-collapsed", sidebarCollapsed);
      if (sidebarToggle) {
        sidebarToggle.setAttribute("aria-expanded", String(!sidebarCollapsed));
      }
    }

    if (sidebarToggle) {
      sidebarToggle.addEventListener("click", () => setSidebarCollapsed(false));
    }
    if (sidebarClose) {
      sidebarClose.addEventListener("click", () => setSidebarCollapsed(true));
    }

    function normalizeRouteKey(value) {
      if (value == null) return "";
      return String(value).trim();
    }

    function getBaseRouteKey(value) {
      const normalized = normalizeRouteKey(value);
      if (!normalized) return "";
      const [base] = normalized.split("_");
      return base || normalized;
    }

    function formatRouteLabel(routeId, fallback = "") {
      const base = getBaseRouteKey(routeId);
      // For the aggregated base route label, prefer the metadata for the `_0` variant when available.
      let metaVariantId = routeId;
      if (routeId && !routeId.includes("_") && base) {
        const preferred = `${base}_0`;
        if (ROUTE_DETAILS.has(preferred) || ROUTE_TRANSLATOR.byId[preferred]) {
          metaVariantId = preferred;
        }
      }
      const metaVariant = metaVariantId ? ROUTE_DETAILS.get(metaVariantId) : null;
      const metaBase = base ? BASE_ROUTE_DETAILS.get(base) : null;
      const shortName = (metaVariant?.shortName || metaBase?.shortName || translateRoute(metaVariantId) || translateRoute(routeId) || translateRoute(base) || "").trim();
      const longName = (metaVariant?.longName || metaBase?.longName || "").trim();
      const fallbackClean = (fallback || "").trim();
      const parts = [];
      if (shortName) parts.push(shortName);
      if (longName) parts.push(longName);
      if (!parts.length && fallbackClean) parts.push(fallbackClean);
      if (!parts.length && base) parts.push(base);
      return parts.join(" ").trim();
    }

    function resolvePublicRouteLabel(value) {
      const raw = normalizeRouteKey(value);
      const base = getBaseRouteKey(raw);
      // Prefer the label already loaded do routes.txt; fallback to formatted label, otherwise raw.
      return routeLabelById.get(base) || routeLabelById.get(raw) || formatRouteLabel(raw, raw);
    }

    function formatVariantLabel(routeId, fallback = "") {
      // Keep variant labels clean (no "(Var. X)" suffix); use the best known name for that variant id.
      return formatRouteLabel(routeId, fallback);
    }

    function refreshRouteLabels() {
      let dirty = false;
      routeOptions.forEach((entry, baseId) => {
        const updatedLabel = formatRouteLabel(baseId);
        if (entry.label !== updatedLabel) {
          entry.label = updatedLabel;
          dirty = true;
        }
        if (entry.variants) {
          entry.variants.forEach((label, variantId) => {
            const updatedVariantLabel = formatVariantLabel(variantId);
            if (label !== updatedVariantLabel) {
              entry.variants.set(variantId, updatedVariantLabel);
              dirty = true;
            }
          });
        }
      });
      if (dirty) {
        rebuildRouteSuggestions();
        updateVariantOptions();
      }
    }

    function refreshRouteTaxonomy() {
      let dirty = false;
      routeOptions.forEach((entry, baseId) => {
        const labels = [];
        const baseLabel = formatRouteLabel(baseId, entry.label || baseId);
        if (baseLabel) labels.push(baseLabel);
        labels.push(translateRoute(baseId), baseId);
        if (entry?.variants) {
          entry.variants.forEach((label, variantId) => {
            if (label) labels.push(label);
            labels.push(translateRoute(variantId), variantId);
          });
        }

        const nextCategories = new Set();
        const nextZones = new Set();
        labels.forEach(label => {
          const cat = definirCategoria(label);
          if (cat) nextCategories.add(cat);
          const zone = definirZona(label);
          if (zone) nextZones.add(zone);
        });

        const categoriesChanged =
          !entry.categories ||
          entry.categories.size !== nextCategories.size ||
          Array.from(nextCategories).some(cat => !entry.categories.has(cat));
        const zonesChanged =
          !entry.zones ||
          entry.zones.size !== nextZones.size ||
          Array.from(nextZones).some(zone => !entry.zones.has(zone));
        if (categoriesChanged) {
          entry.categories = nextCategories;
          dirty = true;
        }
        if (zonesChanged) {
          entry.zones = nextZones;
          dirty = true;
        }
      });
      if (dirty) {
        rebuildRouteSuggestions();
      }
    }

    function initCategoryFilter() {
      if (!categorySelect) return;
      categorySelect.innerHTML = "";
      categorySelect.appendChild(new Option("Todas", CATEGORY_FILTER_ALL));
      STANDARD_ROUTE_CATEGORIES.forEach(cat => {
        categorySelect.appendChild(new Option(cat, cat));
      });
      categorySelect.value = CATEGORY_FILTER_ALL;
      categorySelect.addEventListener("change", () => {
        selectedCategory = categorySelect.value || CATEGORY_FILTER_ALL;
        rebuildRouteSuggestions();
        closeFloatingSearch();
        selectedRoute = ROUTE_FILTER_ALL;
        syncRouteInputValue();
        selectedVariant = VARIANT_FILTER_ALL;
        updateVariantOptions();
        renderVehicles();
        refreshRouteOverlay(true).catch(() => {});
        refreshGlobalStops(true).catch(() => {});
        refreshKpis(true);
        refreshCharts(true).catch(() => {});
        updateRouteClearVisibility();
        renderSelectedRoutePill();
      });
    }

    function handleRouteInputFocus() {
      if (!routeInput) return;
      routeInput.dataset.previousRoute = selectedRoute || ROUTE_FILTER_ALL;
      routeInput.dataset.focusCleared = "true";
      routeInput.value = "";
    }

    function findBestRouteSuggestion(query) {
      if (!routeDatalist || !query) return null;
      const normalizedQuery = query.trim().toLowerCase();
      if (!normalizedQuery) return null;
      let bestOption = null;
      let bestScore = Number.POSITIVE_INFINITY;
      Array.from(routeDatalist.options).forEach(option => {
        const label = (option.value || option.textContent || "").trim();
        if (!label) return;
        const lowerLabel = label.toLowerCase();
        let score = 3;
        if (lowerLabel === normalizedQuery) {
          score = 0;
        } else if (lowerLabel.startsWith(normalizedQuery)) {
          score = 1;
        } else if (lowerLabel.includes(normalizedQuery)) {
          score = 2;
        }
        if (score < bestScore) {
          bestScore = score;
          bestOption = option;
        }
      });
      if (bestOption) {
        return (bestOption.value || bestOption.textContent || "").trim() || null;
      }
      const firstOption = routeDatalist.querySelector("option");
      return firstOption ? ((firstOption.value || firstOption.textContent || "").trim() || null) : null;
    }

    function handleRouteInputKeyDown(event) {
      if (!routeInput) return;
      if (event.key !== "Enter") return;
      const trimmed = routeInput.value?.trim();
      if (!trimmed) return;
      const suggestion = findBestRouteSuggestion(trimmed);
      if (!suggestion) return;
      event.preventDefault();
      routeInput.dataset.focusCleared = "false";
      routeInput.value = suggestion;
      handleRouteInputCommit();
    }

    function updateRoutePreviewPosition() {
      if (!routePreview || !routeInput) return;
      const rect = routeInput.getBoundingClientRect();
      const top = rect.bottom + window.scrollY + 4;
      const left = rect.left + window.scrollX;
      routePreview.style.top = `${top}px`;
      routePreview.style.left = `${left}px`;
      routePreview.style.minWidth = `${rect.width}px`;
      routePreview.style.maxWidth = `${Math.max(rect.width, 320)}px`;
    }
    const updateRoutePreviewPositionDebounced = debounce(updateRoutePreviewPosition, 160);

    function updateRouteClearVisibility() {
      const isGlobal = !selectedRoute || selectedRoute === ROUTE_FILTER_ALL;
      if (routeClear) {
        routeClear.classList.toggle("hidden", isGlobal);
        routeClear.setAttribute("aria-hidden", isGlobal ? "true" : "false");
      }
      if (routeInputWrapper) {
        routeInputWrapper.classList.toggle("pill-visible", !isGlobal && !routeInputWrapper.classList.contains("input-focused"));
      }
    }

    function previewEntries(query) {
      if (!routeOptions) return [];
      const normalized = (query || "").trim().toLowerCase();
      const entries = [];
      routeOptions.forEach((data, baseId) => {
        const label = data.label || baseId;
        if (!routeMatchesSelectedCategory(data, baseId, label)) return;
        const translated = baseId.includes("_") ? translateRoute(baseId) : label;
        const { code, codeBase } = parseRouteCodeParts(translated || label);
        const haystacks = [
          (label || "").toLowerCase(),
          (translated || "").toLowerCase(),
          (code || "").toLowerCase(),
          (codeBase || "").toLowerCase()
        ].filter(Boolean);
        if (normalized) {
          const match = haystacks.some(h => h.includes(normalized));
          if (!match) return;
        }
        entries.push({ id: baseId, label: translated || label });
      });
      const collator = new Intl.Collator("pt-PT", { numeric: true, sensitivity: "base" });
      entries.sort((a, b) => collator.compare(a.label, b.label));
      return entries;
    }

    function renderRoutePreview(query) {
      if (!routePreview) return;
      const entries = previewEntries(query);
      if (!entries.length) {
        routePreview.classList.add("hidden");
        routePreview.innerHTML = "";
        return;
      }
      const html = entries.map(({ id, label }) => {
        const displayLabel = label || id;
        const style = pillStyleForRoute(displayLabel);
        const { code } = parseRouteCodeParts(displayLabel);
        const pillText = code || displayLabel || id;
        const regex = code ? new RegExp(`^${escapeRegex(code)}\\s*`, "i") : null;
        const restLabel = regex ? (displayLabel.replace(regex, "").trim() || displayLabel) : displayLabel;
        const safeLabel = escapeHtml(restLabel);
        const safeId = escapeHtml(id);
        const pill = `<span class="route-pill" aria-hidden="true" style="--pill-bg:${style.bg};--pill-fg:${style.fg};--pill-border:${style.border}">${escapeHtml(pillText)}</span>`;
        return `<div class="preview-item" role="option" data-route-id="${safeId}">
          <span class="preview-label">${pill} ${safeLabel}</span>
        </div>`;
      }).join("");
      routePreview.innerHTML = html;
      routePreview.classList.remove("hidden");
      updateRoutePreviewPositionDebounced();
      Array.from(routePreview.querySelectorAll(".preview-item")).forEach(item => {
        if (item.dataset.bound === "1") return;
        item.dataset.bound = "1";
        item.addEventListener("mousedown", ev => {
          ev.preventDefault();
          const rid = item.dataset.routeId || "";
          routeInput.value = routeLabelById.get(rid) || rid;
          routeInput.dataset.focusCleared = "false";
          selectedRoute = rid || ROUTE_FILTER_ALL;
          selectedVariant = VARIANT_FILTER_ALL;
          updateVariantOptions();
          renderVehicles();
          refreshRouteOverlay(true).catch(() => {});
          refreshGlobalStops(true).catch(() => {});
          refreshCharts(true).catch(() => {});
          refreshKpis(true);
          updateRouteClearVisibility();
          renderSelectedRoutePill();
          routeInputWrapper?.classList.remove("input-focused");
          routePreview.classList.add("hidden");
        });
      });
    }

    function renderSelectedRoutePill() {
      if (!routeSelectedPill || !routeSelectedText || !routeInputWrapper) return;
      updateRouteClearVisibility();
      const isGlobal = !selectedRoute || selectedRoute === ROUTE_FILTER_ALL;
      if (isGlobal) {
      routeSelectedPill.classList.add("hidden");
      return;
    }
    const displayLabel = resolvePublicRouteLabel(selectedRoute);
    const { code } = parseRouteCodeParts(displayLabel);
    const pillText = code || displayLabel || selectedRoute;
    const style = pillStyleForRoute(displayLabel);
    const regex = code ? new RegExp(`^${escapeRegex(code)}\\s*`, "i") : null;
    const restLabel = regex ? (displayLabel.replace(regex, "").trim() || displayLabel) : displayLabel;
    const safeRest = escapeHtml(restLabel);
    routeSelectedText.innerHTML = `<span class="route-pill route-pill--inline" style="--pill-bg:${style.bg};--pill-fg:${style.fg};--pill-border:${style.border}">${escapeHtml(pillText)}</span> <span class="route-title-rest" title="${safeRest}">${safeRest}</span>`;
    routeSelectedPill.classList.remove("hidden");
    routeInputWrapper.classList.add("pill-visible");
  }

    function initRouteFilter() {
      if (!routeInput || !routeDatalist) return;
      routeInput.value = ROUTE_GLOBAL_LABEL;
      // Prevent native datalist dropdown; we render our own preview list.
      routeInput.removeAttribute("list");
      routeInput.addEventListener("focus", handleRouteInputFocus);
      routeInput.addEventListener("keydown", handleRouteInputKeyDown);
      routeInput.addEventListener("change", handleRouteInputCommit, { passive: true });
      routeInput.addEventListener("blur", handleRouteInputCommit);
      routeInput.addEventListener("input", () => {
        renderRoutePreview(routeInput.value || "");
        updateRoutePreviewPositionDebounced();
      });
      routeInput.addEventListener("focus", () => {
        renderRoutePreview(routeInput.value || "");
        updateRoutePreviewPositionDebounced();
        routeInputWrapper?.classList.add("input-focused");
        routeInputWrapper?.classList.remove("pill-visible");
        updateRouteClearVisibility();
      });
      routeInput.addEventListener("blur", () => {
        setTimeout(() => routePreview?.classList.add("hidden"), 120);
        routeInputWrapper?.classList.remove("input-focused");
        updateRouteClearVisibility();
      });
      window.addEventListener("resize", updateRoutePreviewPositionDebounced, { passive: true });
      window.addEventListener("scroll", updateRoutePreviewPositionDebounced, { passive: true });
      if (routeClear) {
        routeClear.addEventListener("click", () => {
          clearRouteSelection();
        });
      }
      if (routeSelectedPill) {
        routeSelectedPill.addEventListener("click", () => {
          routeInputWrapper?.classList.remove("pill-visible");
          routeInputWrapper?.classList.add("input-focused");
          routeInput?.focus();
          routeInput?.select();
        });
        routeSelectedPill.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter" || ev.key === " ") {
            ev.preventDefault();
            routeInputWrapper?.classList.remove("pill-visible");
            routeInputWrapper?.classList.add("input-focused");
            routeInput?.focus();
            routeInput?.select();
          }
        });
      }
      updateRouteClearVisibility();
      renderSelectedRoutePill();
    }

    function initFloatingSearch() {
      if (!floatingRouteInput) return;
      floatingRouteInput.addEventListener("input", () => renderFloatingRoutePreview(floatingRouteInput.value || ""));
      floatingRouteInput.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter") {
          ev.preventDefault();
          handleFloatingRouteCommit();
        } else if (ev.key === "Escape") {
          ev.preventDefault();
          closeFloatingSearch();
        }
      });
      floatingRouteInput.addEventListener("focus", () => {
        renderFloatingRoutePreview(floatingRouteInput.value || "");
      });
      floatingRouteInput.addEventListener("blur", () => {
        setTimeout(() => closeFloatingSearch(), 140);
      });
      if (floatingSearch) {
        floatingSearch.addEventListener("click", (ev) => ev.stopPropagation());
      }
      document.addEventListener("click", (ev) => {
        if (!isMobileViewport()) return;
        if (!floatingSearch || !floatingSearch.classList.contains("visible")) return;
        if (floatingSearch.contains(ev.target) || kpiFloatingChip?.contains?.(ev.target)) return;
        closeFloatingSearch();
      });
    }

    function initVariantFilter() {
      if (!variantSelect) return;
      variantSelect.innerHTML = "";
      variantSelect.appendChild(new Option("Todas as variantes", VARIANT_FILTER_ALL));
      variantSelect.value = VARIANT_FILTER_ALL;
      variantSelect.addEventListener("change", () => {
        selectedVariant = variantSelect.value || VARIANT_FILTER_ALL;
        renderVehicles();
        refreshRouteOverlay(true).catch(() => {});
        refreshGlobalStops(true).catch(() => {});
        refreshKpis(true);
        refreshCharts(true).catch(() => {});
      });
    }

	    function formatUpdateAge(timestamp) {
	      if (!timestamp) return "‚Äî";
	      const ms = Date.now() - new Date(timestamp).getTime();
	      if (!Number.isFinite(ms) || ms < 0) return "‚Äî";
	      const seconds = Math.round(ms / 1000);
	      if (seconds < 60) return `${seconds}s`;
	      if (seconds < 3600) return `${Math.round(seconds / 60)}m`;
	      return `${Math.round(seconds / 3600)}h`;
	    }

	    function formatSpeedValue(value) {
	      if (!Number.isFinite(Number(value))) return null;
	      const rounded = Math.round(Number(value) * 10) / 10;
	      return rounded.toFixed(1);
	    }

    function normalizeContext(context) {
      if (context && typeof context === "object") {
        return { text: context.text || "", html: context.html || null };
      }
      const text = context == null ? "" : String(context);
      return { text, html: null };
    }

    function isMobileViewport() {
      return window.matchMedia && window.matchMedia("(max-width: 900px)").matches;
    }

    function buildCategoryContext(categoryName) {
      const cat = categoryName || selectedCategory;
      if (!cat || cat === CATEGORY_FILTER_ALL) return null;
      const bg = pillBgForCategory(cat);
      const fg = readableTextColor(bg, "#0b1220");
      const border = "rgba(15, 23, 42, 0.12)";
      const html = `<span class="route-pill route-pill--inline" style="--pill-bg:${bg};--pill-fg:${fg};--pill-border:${border}">${escapeHtml(cat)}</span>`;
      return { text: cat, html };
    }

    function buildFloatingContext(contextOverride) {
      if (contextOverride) return normalizeContext(contextOverride);
      if (selectedRoute && selectedRoute !== ROUTE_FILTER_ALL) {
        return buildRouteContext();
      }
      const catCtx = buildCategoryContext(selectedCategory);
      if (catCtx) return catCtx;
      return { text: "Rede Global", html: null };
    }

    function updateFloatingContext(context) {
      if (!kpiFloatingText) return;
      const ctx = buildFloatingContext(context);
      if (ctx.html) {
        kpiFloatingText.innerHTML = ctx.html;
      } else {
        kpiFloatingText.textContent = ctx.text || "Rede Global";
      }
      const aria = ctx.text || "Rede Global";
      const isGlobal =
        (!selectedRoute || selectedRoute === ROUTE_FILTER_ALL) &&
        (!selectedCategory || selectedCategory === CATEGORY_FILTER_ALL);
      if (kpiFloatingClear) {
        kpiFloatingClear.classList.toggle("hidden", isGlobal);
        kpiFloatingClear.setAttribute("aria-hidden", isGlobal ? "true" : "false");
      }
      if (kpiFloatingChip) {
        kpiFloatingChip.setAttribute("aria-label", isGlobal ? "Pesquisar carreira" : `${aria} (clique para pesquisar)`);
      }
      kpiFloatingText.setAttribute("aria-label", aria);
    }

    function focusRouteSearchFromFloating() {
      if (isMobileViewport() && floatingSearch && floatingRouteInput) {
        openFloatingSearch();
        return;
      }
      setSidebarCollapsed(false);
      if (!routeInput) return;
      try { routeInput.focus({ preventScroll: true }); } catch (e) { routeInput.focus(); }
      routeInput.select();
      if (!selectedRoute || selectedRoute === ROUTE_FILTER_ALL) {
        routeInput.value = "";
      }
      renderRoutePreview(routeInput.value || "");
      updateRoutePreviewPositionDebounced();
    }

    function resetFiltersToGlobal() {
      const categoryNeedsReset = categorySelect && categorySelect.value !== CATEGORY_FILTER_ALL;
      if (categoryNeedsReset) {
        categorySelect.value = CATEGORY_FILTER_ALL;
        categorySelect.dispatchEvent(new Event("change", { bubbles: true }));
      }
      else {
        clearRouteSelection();
      }
      closeFloatingSearch();
      updateFloatingContext(buildFloatingContext());
    }

    function startKpiAgeTicker() {
      if (kpiAgeTimer) return;
      kpiAgeTimer = setInterval(() => {
        if (!lastKpiTimestamp) return;
        if (kpiLastUpdate) {
          const age = formatUpdateAge(lastKpiTimestamp);
          kpiLastUpdate.textContent = age && age !== "‚Äî" ? `Atualizado h√° ${age}` : "Sem dados recentes";
        }
      }, 1000);
    }

	    function formatDeltaValue(value) {
	      if (!Number.isFinite(Number(value))) return null;
	      const delta = Number(value);
	      if (delta === 0) return { text: "‚Äî", className: "kpi-delta zero" };
	      const arrow = delta > 0 ? "‚Üë" : "‚Üì";
	      return { text: `${arrow} ${Math.abs(delta).toFixed(1)} km/h`, className: delta > 0 ? "kpi-delta positive" : "kpi-delta negative" };
	    }

    function updateKpiDelta(value) {
      if (!kpiVelHourDelta) return;
      const formatted = formatDeltaValue(value);
      if (!formatted) {
        kpiVelHourDelta.textContent = "‚Äî";
        kpiVelHourDelta.className = "kpi-delta";
        return;
      }
      kpiVelHourDelta.textContent = formatted.text;
      kpiVelHourDelta.className = formatted.className;
    }

    function updateKpiDisplay(row, contextText) {
      if (!kpiPanel) return;
      lastKpiTimestamp = row && row.timestamp ? row.timestamp : null;
      if (kpiLastUpdate) {
        const age = lastKpiTimestamp ? formatUpdateAge(lastKpiTimestamp) : null;
        kpiLastUpdate.textContent = age && age !== "‚Äî" ? `Atualizado h√° ${age}` : "Sem dados recentes";
      }
      startKpiAgeTicker();
      kpiActiveVehicles.textContent = row ? String(Math.round(row.veiculos_ativos ?? 0)) : "‚Äî";
	      const velDayText = row ? formatSpeedValue(row.vel_comercial ?? NaN) : null;
	      if (kpiVelDay) {
	        kpiVelDay.textContent = velDayText ?? "‚Äî";
	        kpiVelDay.classList.toggle("has-unit", Boolean(velDayText));
	      }
	      const velHourText = row ? formatSpeedValue(row.vel_comercial_1h ?? NaN) : null;
      if (kpiVelHour) {
        kpiVelHour.textContent = velHourText ?? "‚Äî";
        kpiVelHour.classList.toggle("has-unit", Boolean(velHourText));
      }
      const ctx = normalizeContext(contextText);
      if (kpiContext) kpiContext.textContent = ctx.text || "‚Äî";
      updateFloatingContext(ctx);
      updateKpiDelta(row?.delta_vel_comercial);
    }

    function safeNumber(value) {
      const num = Number(value);
      return Number.isFinite(num) ? num : 0;
    }

    function getRouteLineCandidates() {
      const candidates = [];
      const pushCandidate = value => {
        if (!value || value === VARIANT_FILTER_ALL || value === ROUTE_FILTER_ALL) return;
        if (!candidates.includes(value)) candidates.push(value);
      };
      // If a specific variant is selected, use it; otherwise prefer the aggregated base route id
      // so "Todas as variantes" aggregates KPI/chart data (like the Python dashboard).
      if (selectedVariant && selectedVariant !== VARIANT_FILTER_ALL) {
        pushCandidate(selectedVariant);
      } else if (selectedRoute && selectedRoute !== ROUTE_FILTER_ALL) {
        pushCandidate(getBaseRouteKey(selectedRoute));
      }
      // Keep some fallbacks for more tolerant backends.
      pushCandidate(selectedRoute);
      pushCandidate(getBaseRouteKey(selectedRoute));
      return candidates;
    }

    function buildVehicleQueryParams() {
      const params = {};
      if (selectedCategory && selectedCategory !== CATEGORY_FILTER_ALL) {
        params.categoria = selectedCategory;
      }
      const routeCandidates = getRouteLineCandidates();
      if (routeCandidates.length > 0) {
        params.linha = routeCandidates[0];
      }
      return params;
    }

    function buildTrendQueryParams(lineCandidate) {
      const today = new Date().toISOString().split("T")[0];
      const params = {
        date: today,
        hora_inicio: "00:00:00",
        hora_fim: "23:59:59",
      };
      if (lineCandidate) {
        params.line_id = lineCandidate;
        params.linha = lineCandidate;
      } else if (selectedCategory && selectedCategory !== CATEGORY_FILTER_ALL) {
        params.categoria = selectedCategory;
      }
      return params;
    }

    async function fetchTrendSummary(lineCandidate) {
      const params = buildTrendQueryParams(lineCandidate);
      const payload = await fetchFromEndpoints(CHARTS_ENDPOINTS, params).catch(err => {
        console.warn("Falha ao buscar gr√°ficos:", err);
        return null;
      });
      return normalizeTrendPayload(payload);
    }

    function parseRowTimestamp(row) {
      const raw = row?.timestamp_intervalo ?? row?.timestamp_bloco ?? row?.ts_ref ?? row?.timestamp;
      if (!raw) return null;
      const dt = new Date(raw);
      return Number.isFinite(dt.getTime()) ? dt : null;
    }

    function computeRouteKpiFromRows(rows) {
      if (!Array.isArray(rows) || rows.length === 0) return null;
      const enriched = rows.map(row => ({ row, ts: parseRowTimestamp(row) })).filter(item => item.ts);
      if (!enriched.length) return null;
      enriched.sort((a, b) => a.ts - b.ts);
      const totalDistance = enriched.reduce((sum, item) => sum + safeNumber(item.row.distancia_total), 0);
      const totalTime = enriched.reduce(
        (sum, item) => sum + safeNumber(item.row.tempo_operacao_s ?? item.row.tempo_operacao_seg),
        0
      );
      const velDay = totalTime > 0 ? totalDistance / (totalTime / 3600.0) : null;
      const nowMs = Date.now();
      const cutoffHour = nowMs - 60 * 60 * 1000;
      const lastHourItems = enriched.filter(item => {
        const t = item.ts.getTime();
        return t >= cutoffHour && t <= nowMs;
      });
      const lastHourSum = lastHourItems.reduce(
        (sum, item) => sum + safeNumber(item.row.velocidade_media ?? item.row.velocidade_comercial ?? item.row.vel_comercial),
        0
      );
      const velHour =
        lastHourItems.length > 0 ? lastHourSum / lastHourItems.length : velDay ?? 0;
      const latest = enriched[enriched.length - 1];
      const vehicles =
        safeNumber(
          latest.row.num_veiculos ??
          latest.row.Volume_Frota ??
          latest.row.Volume_Frota_Ativa ??
          latest.row.volume_frota ??
          latest.row.volume ??
          latest.row.Volume ??
          latest.row.numVeiculos
        );
      const deltaVel = (velHour ?? 0) - (velDay ?? velHour ?? 0);
      return {
        timestamp: latest.ts.toISOString(),
        veiculos_ativos: Math.round(vehicles),
        vel_comercial: Number.isFinite(velDay) ? Number(velDay) : Number(velHour ?? 0),
        vel_comercial_1h: Number.isFinite(velHour) ? Number(velHour) : Number(velDay ?? 0),
        delta_vel_comercial: Number.isFinite(deltaVel) ? Number(deltaVel) : 0,
      };
    }

    const TREND_BUCKET_MS = 5 * 60 * 1000;
    const TREND_MAX_SPAN_MINUTES = 25;
    const TREND_MAX_SPAN_BUCKETS = Math.floor((TREND_MAX_SPAN_MINUTES * 60 * 1000) / TREND_BUCKET_MS);

    function aggregateTrendRows(rows) {
      if (!Array.isArray(rows) || rows.length === 0) return [];
      const buckets = new Map();
      const intervalMs = TREND_BUCKET_MS;
      rows.forEach(row => {
        const rawTimestamp = row.timestamp_intervalo || row.timestamp_bloco || row.ts_ref || row.timestamp;
        if (!rawTimestamp) return;
        const parsed = new Date(rawTimestamp);
        if (!Number.isFinite(parsed.getTime())) return;
        const bucketKey = Math.floor(parsed.getTime() / intervalMs) * intervalMs;
        const bucket = buckets.get(bucketKey) || {
          distancia_total: 0,
          tempo_operacao_s: 0,
          velocidade_sum: 0,
          velocidade_count: 0,
          num_veiculos: 0
        };
        bucket.distancia_total += safeNumber(row.distancia_total);
        bucket.tempo_operacao_s += safeNumber(row.tempo_operacao_s ?? row.tempo_operacao_seg);
        const rawSpeed = row.velocidade_media ?? row.velocidade_comercial ?? row.vel_comercial;
        const media = Number(rawSpeed);
        if (Number.isFinite(media)) {
          bucket.velocidade_sum += media;
          bucket.velocidade_count += 1;
        }
        const volumeValue =
          row.num_veiculos ??
          row.Volume_Frota ??
          row.Volume_Frota_Ativa ??
          row.volume_frota ??
          row.volume ??
          row.Volume ??
          row.numVeiculos;
        bucket.num_veiculos += safeNumber(volumeValue);
        buckets.set(bucketKey, bucket);
      });
      const sorted = Array.from(buckets.entries()).sort((a, b) => a[0] - b[0]);
      const timeline = sorted.map(([timestamp, data]) => {
        const interval = new Date(Number(timestamp));
        const meanSpeed = data.velocidade_count > 0 ? data.velocidade_sum / data.velocidade_count : 0;
        const velocidade = data.tempo_operacao_s > 0
          ? data.distancia_total / (data.tempo_operacao_s / 3600.0)
          : meanSpeed;
        return {
          interval,
          velComercial: Number.isFinite(velocidade) ? velocidade : 0,
          volume: Number.isFinite(data.num_veiculos) ? data.num_veiculos : 0
        };
      });
      return applyRollingAverage(timeline);
    }

    function applyRollingAverage(entries) {
      const windowMs = 15 * 60 * 1000;
      return entries.map((entry, index) => {
        const currentMs = entry.interval.getTime();
        let sum = 0;
        let count = 0;
        for (let cursor = index; cursor >= 0; cursor -= 1) {
          const previous = entries[cursor];
          const delta = currentMs - previous.interval.getTime();
          if (delta > windowMs) break;
          const value = previous.velComercial;
          if (Number.isFinite(value)) {
            sum += value;
            count += 1;
          }
        }
        return {
          ...entry,
          vel15m: count ? sum / count : entry.velComercial
        };
      });
    }

    function normalizeTimelineEntries(entries) {
      if (!Array.isArray(entries)) return [];
      const mapped = entries
        .map(entry => {
          const ts = parseRowTimestamp(entry);
          if (!ts) return null;
          const baseSpeed = Number(
            entry.vel_comercial ??
            entry.velComercial ??
            entry.velocidade ??
            entry.velocidade_comercial ??
            entry.velocidade_media ??
            entry.velocidade
          );
          const vel15 = Number(entry.vel_15m ?? entry.vel15m ?? entry.vel_media_15 ?? entry.vel_media_15m);
          const volumeRaw =
            entry.volume ??
            entry.num_veiculos ??
            entry.Volume_Frota ??
            entry.Volume_Frota_Ativa ??
            entry.volume_frota ??
            entry.volume ??
            entry.Volume ??
            entry.numVeiculos;
          return {
            interval: ts,
            velComercial: Number.isFinite(baseSpeed) ? baseSpeed : 0,
            vel15m: Number.isFinite(vel15) ? vel15 : null,
            volume: Number.isFinite(Number(volumeRaw)) ? Number(volumeRaw) : 0
          };
        })
        .filter(Boolean)
        .sort((a, b) => a.interval - b.interval);
      return mapped;
    }

    function densifyTrendTimeline(entries) {
      if (!Array.isArray(entries) || entries.length === 0) return [];
      const sorted = entries.slice().sort((a, b) => a.interval - b.interval);
      const byMs = new Map();
      for (const entry of sorted) {
        const bucketMs = Math.floor(entry.interval.getTime() / TREND_BUCKET_MS) * TREND_BUCKET_MS;
        byMs.set(bucketMs, { ...entry, interval: new Date(bucketMs) });
      }
      const startMs = Math.floor(sorted[0].interval.getTime() / TREND_BUCKET_MS) * TREND_BUCKET_MS;
      const endMs = Math.floor(sorted[sorted.length - 1].interval.getTime() / TREND_BUCKET_MS) * TREND_BUCKET_MS;
      const result = [];
      for (let t = startMs; t <= endMs; t += TREND_BUCKET_MS) {
        const existing = byMs.get(t);
        if (existing) {
          result.push(existing);
        } else {
          result.push({
            interval: new Date(t),
            velComercial: null,
            vel15m: null,
            volume: null
          });
        }
      }
      return result;
    }

    function buildSegmentedLineDatasets({ values, label, color, fill, fillMode, borderWidth = 2, tension = 0.2 }) {
      const datasets = [];
      let lastDefinedIndex = null;
      let segmentStart = null;

      const pushSegment = (startIndex, endIndex) => {
        if (startIndex == null || endIndex == null || endIndex < startIndex) return;
        const data = new Array(values.length).fill(null);
        for (let i = startIndex; i <= endIndex; i += 1) {
          data[i] = values[i];
        }
        datasets.push({
          label,
          data,
          borderColor: color,
          backgroundColor: fill,
          borderWidth,
          pointRadius: 0,
          pointHoverRadius: 6,
          pointHitRadius: 12,
          fill: fillMode,
          tension,
          spanGaps: true
        });
      };

      for (let i = 0; i < values.length; i += 1) {
        const val = values[i];
        const isDefined = val != null && Number.isFinite(Number(val));
        if (!isDefined) continue;
        if (lastDefinedIndex == null) {
          segmentStart = i;
        } else {
          const gapBuckets = i - lastDefinedIndex - 1;
          if (gapBuckets > TREND_MAX_SPAN_BUCKETS) {
            pushSegment(segmentStart, lastDefinedIndex);
            segmentStart = i;
          }
        }
        lastDefinedIndex = i;
      }

      if (lastDefinedIndex != null && segmentStart != null) {
        pushSegment(segmentStart, lastDefinedIndex);
      }

      return datasets.length ? datasets : [{
        label,
        data: values,
        borderColor: color,
        backgroundColor: fill,
        borderWidth,
        pointRadius: 0,
        pointHoverRadius: 6,
        pointHitRadius: 12,
        fill: fillMode,
        tension,
        spanGaps: true
      }];
    }

    function ensureRollingTimeline(entries) {
      if (!Array.isArray(entries) || entries.length === 0) return [];
      const hasRolling = entries.some(entry => Number.isFinite(entry.vel15m));
      if (hasRolling) {
        return entries.map(entry => ({
          ...entry,
          vel15m: Number.isFinite(entry.vel15m) ? entry.vel15m : entry.velComercial
        }));
      }
      return applyRollingAverage(entries);
    }

    function normalizeTrendPayload(payload) {
      if (!payload) {
        return { timeline: [], kpi: null, rows: [] };
      }
      if (Array.isArray(payload)) {
        const timelineFromRows = aggregateTrendRows(payload);
        return {
          timeline: ensureRollingTimeline(timelineFromRows),
          kpi: computeRouteKpiFromRows(payload),
          rows: payload
        };
      }
      const rows = Array.isArray(payload.rows)
        ? payload.rows
        : Array.isArray(payload.metricas)
          ? payload.metricas
          : [];
      const timelineRaw = Array.isArray(payload.timeline) ? normalizeTimelineEntries(payload.timeline) : [];
      const timeline = ensureRollingTimeline(timelineRaw.length ? timelineRaw : aggregateTrendRows(rows));
      const kpi = payload.kpi || computeRouteKpiFromRows(rows);
      return { timeline, kpi, rows };
    }

    function filterTrendSummaryByCategory(summary) {
      if (!summary || selectedCategory === CATEGORY_FILTER_ALL) return summary;
      const normalizeCat = (value) => (value || "").toString().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim();
      const target = normalizeCat(selectedCategory);

      const rows = Array.isArray(summary.rows) ? summary.rows : [];
      const timelineRaw = Array.isArray(summary.timeline) ? summary.timeline : [];
      const originalTimeline = ensureRollingTimeline(
        timelineRaw.length ? normalizeTimelineEntries(timelineRaw) : aggregateTrendRows(rows)
      );

      // If the payload already declares the category, trust it.
      const summaryCat = normalizeCat(summary.categoria ?? summary.category);
      if (summaryCat && summaryCat === target) {
        return { ...summary, timeline: originalTimeline, kpi: summary.kpi || computeRouteKpiFromRows(rows) };
      }

      // Special-case Rede Madrugada: some payloads omit linha/categoria but are already scoped.
      if (target === normalizeCat("Rede Madrugada") && rows.length && !timelineRaw.length) {
        return { ...summary, timeline: originalTimeline, kpi: summary.kpi || computeRouteKpiFromRows(rows) };
      }

      const filteredRows = rows.filter(row => {
        const explicitCat = normalizeCat(row?.categoria ?? row?.categoria_frota ?? row?.category);
        if (explicitCat && explicitCat === target) return true;
        const linha = row?.linha ?? row?.line_id ?? row?.line ?? row?.route_id ?? "";
        const inferred = definirCategoria(linha);
        return normalizeCat(inferred) === target;
      });

      const filteredTimeline = timelineRaw.filter(entry => {
        const entryCat = normalizeCat(entry?.categoria ?? entry?.category);
        if (entryCat && entryCat === target) return true;
        const linha = entry?.linha ?? entry?.line_id ?? entry?.line ?? entry?.route_id ?? "";
        const inferred = definirCategoria(linha);
        return normalizeCat(inferred) === target;
      });

      const timeline = ensureRollingTimeline(filteredTimeline.length ? normalizeTimelineEntries(filteredTimeline) : aggregateTrendRows(filteredRows));
      const kpi = computeRouteKpiFromRows(filteredRows);
      if (!filteredRows.length && !timeline.length) {
        // Fall back to original data if backend likely already filtered by category but didn't provide per-line info.
        if (originalTimeline.length || rows.length) {
          return { ...summary, timeline: originalTimeline, kpi: summary.kpi || computeRouteKpiFromRows(rows), rows };
        }
        return { ...summary, rows: [], timeline: [], kpi: null };
      }
      return { ...summary, rows: filteredRows, timeline, kpi };
    }

    function updateTrendTimeline(entries) {
      trendTimeline = densifyTrendTimeline(ensureRollingTimeline(entries));
      updatePreviewChartsDisplay();
      if (currentOverlayType) {
        renderOverlayChart(currentOverlayType);
      }
    }

    function formatTimeOnly(value) {
      if (!value) return "‚Äî";
      const d = new Date(value);
      if (!Number.isFinite(d.getTime())) return String(value);
      return d.toLocaleTimeString("pt-PT", { hour: "2-digit", minute: "2-digit" });
    }

    function formatKm(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "‚Äî";
      return (num / 1000).toFixed(1);
    }

    function statusDotHtml(isActive) {
      const cls = isActive ? "active" : "inactive";
      const label = isActive ? "Ativo" : "Inativo";
      return `<span class="overlay-status-dot ${cls}" title="${label}" aria-label="${label}"></span>`;
    }

    async function checkApiHealth() {
      for (const url of HEALTH_ENDPOINTS) {
        try {
          const resp = await fetch(url, { cache: "no-store" });
          if (resp.ok) return true;
        } catch (err) {
          continue;
        }
      }
      return false;
    }

    function getPrimaryRouteIdForCharts() {
      if (selectedVariant && selectedVariant !== VARIANT_FILTER_ALL) return selectedVariant;
      if (selectedRoute && selectedRoute !== ROUTE_FILTER_ALL) return selectedRoute;
      return null;
    }

    async function fetchRouteDayVehicles(lineId, dateStr) {
      if (!lineId) return [];
      const endpoints = routeDetailEndpoints(lineId, dateStr);
      const params = buildTrendQueryParams(lineId);
      params.line_id = lineId;
      params.linha = lineId;
      try {
        const payload = await fetchFromEndpoints(endpoints, params);
        const rows = Array.isArray(payload) ? payload : (Array.isArray(payload?.rows) ? payload.rows : []);
        return rows;
      } catch (err) {
        console.warn("Falha ao carregar ve√≠culos do dia:", err);
        return [];
      }
    }

    function normalizeVehicleDayRow(row) {
      if (!row || typeof row !== "object") return null;
      const id = row.vehicle_id ?? row.id_veiculo ?? row.veiculo ?? row.id ?? row.vehicle ?? null;
      if (!id) return null;
      const model = row.modelo ?? row.model ?? row.vehicle_model ?? row.tipo ?? row.type ?? "";
      const first = row.first_ping ?? row.primeiro_ping ?? row.hora_inicio ?? row.ts_inicio ?? row.start_time ?? row.primeiro_ts ?? row.timestamp_inicio ?? null;
      const last = row.last_ping ?? row.ultimo_ping ?? row.hora_fim ?? row.ts_fim ?? row.end_time ?? row.ultimo_ts ?? row.timestamp_fim ?? row.ts ?? row.timestamp ?? null;
      const dist =
        row.distancia_total_km ??
        row.distancia_total_m ??
        row.distancia_total ??
        row.distancia ??
        row.km_total ??
        row.total_distance ??
        null;
      const trips = row.viagens ?? row.num_viagens ?? row.trips ?? row.total_trips ?? row.viagens_concluidas ?? null;
      return { id, model, first, last, dist, trips };
    }

    function renderVolumeOverlayTable() {
      if (!chartOverlayExtra || !chartOverlayVehicleRows) return;
      const lineId = getPrimaryRouteIdForCharts();
      if (!lineId) {
        chartOverlayExtra.hidden = true;
        return;
      }
      chartOverlayExtra.hidden = false;
      chartOverlayVehicleRows.innerHTML = `<tr><td colspan="7" class="overlay-empty">A carregar‚Ä¶</td></tr>`;
      const today = new Date().toISOString().split("T")[0];
      return fetchRouteDayVehicles(lineId, today).then(rows => {
        const normalized = rows.map(normalizeVehicleDayRow).filter(Boolean);
        const unique = [];
        const seen = new Set();
        normalized.forEach(row => {
          if (seen.has(row.id)) return;
          seen.add(row.id);
          unique.push(row);
        });
        if (!unique.length) {
          chartOverlayVehicleRows.innerHTML = `<tr><td colspan="7" class="overlay-empty">Sem dados desta carreira para hoje.</td></tr>`;
          return;
        }
        const html = unique.map(row => {
          const active = row.last && (new Date(row.last).getTime() >= (Date.now() - 10 * 60 * 1000));
          return `<tr>
            <td>${escapeHtml(row.id || "‚Äî")}</td>
            <td>${escapeHtml(row.model || "‚Äî")}</td>
            <td>${escapeHtml(formatTimeOnly(row.first))}</td>
            <td>${escapeHtml(formatTimeOnly(row.last))}</td>
            <td>${escapeHtml(formatKm(row.dist))}</td>
            <td>${escapeHtml(row.trips != null ? String(row.trips) : "‚Äî")}</td>
            <td>${statusDotHtml(active)}</td>
          </tr>`;
        }).join("");
        chartOverlayVehicleRows.innerHTML = html;
      }).catch(err => {
        console.warn("Falha ao carregar ve√≠culos do dia:", err);
        chartOverlayVehicleRows.innerHTML = `<tr><td colspan="7" class="overlay-empty">Erro ao carregar dados.</td></tr>`;
      });
    }

    function updatePreviewChartsDisplay() {
      const labels = trendTimeline.map(entry => timeLabelFormatter.format(entry.interval));
      if (previewCharts.speed) {
        previewCharts.speed.data.labels = labels;
        const values = trendTimeline.map(entry =>
          Number.isFinite(entry.vel15m) ? Number(entry.vel15m.toFixed(1)) : null
        );
        previewCharts.speed.data.datasets = buildSegmentedLineDatasets({
          values,
          label: "Velocidade Comercial",
          color: "#ff4b4b",
          fill: "transparent",
          fillMode: false,
          borderWidth: 2,
          tension: 0.3
        });
        previewCharts.speed.update("none");
      }
      if (previewCharts.volume) {
        previewCharts.volume.data.labels = labels;
        const values = trendTimeline.map(entry =>
          Number.isFinite(entry.volume) ? Number(entry.volume.toFixed(0)) : null
        );
        previewCharts.volume.data.datasets = buildSegmentedLineDatasets({
          values,
          label: "Volume da Frota",
          color: "#f59f00",
          fill: "rgba(245, 159, 0, 0.25)",
          fillMode: "start",
          borderWidth: 2,
          tension: 0.3
        });
        previewCharts.volume.update("none");
      }
    }

	    function initPreviewCharts() {
	      if (window.Chart && chartSpeedCanvas) {
	        previewCharts.speed = new Chart(chartSpeedCanvas.getContext("2d"), {
	          type: "line",
	          data: {
	            labels: [],
	            datasets: [{
	              label: "Velocidade Comercial",
	              data: [],
	              borderColor: "#ff4b4b",
	              backgroundColor: "transparent",
	              borderWidth: 2,
	              pointRadius: 0,
	              fill: false,
	              tension: 0.3,
	              spanGaps: true
	            }]
	          },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { legend: { display: false } },
              scales: {
                x: { display: false },
                y: { display: false, min: 0 }
              }
            }
        });
      }
      if (window.Chart && chartVolumeCanvas) {
        previewCharts.volume = new Chart(chartVolumeCanvas.getContext("2d"), {
          type: "line",
          data: {
            labels: [],
            datasets: [{
              label: "Volume da Frota",
              data: [],
              borderColor: "#f59f00",
              backgroundColor: "rgba(245, 159, 0, 0.25)",
              borderWidth: 2,
              pointRadius: 0,
              fill: "start",
              tension: 0.3,
              spanGaps: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
              x: { display: false },
              y: { display: false, min: 0 }
            }
          }
        });
      }
    }

    async function refreshCharts(force = false) {
      const routeCandidates = getRouteLineCandidates();
      const chartLineCandidates = [...routeCandidates, null];
      const now = Date.now();
      let found = false;

      if (!force) {
        if (now - lastChartFetchTs < CHARTS_MIN_INTERVAL_MS && chartCache.summary) {
          lastTrendSummary = { ...(chartCache.summary || {}), lineCandidate: chartCache.lineCandidate ?? null };
          lastTrendLineCandidate = chartCache.lineCandidate ?? null;
          updateTrendTimeline(lastTrendSummary.timeline || []);
          return lastTrendSummary;
        }
      }

      for (const candidate of chartLineCandidates) {
        const params = buildTrendQueryParams(candidate);
        const paramsKey = JSON.stringify(params);

        if (!force && paramsKey === chartCache.paramsKey && now - chartCache.timestamp < CHARTS_CACHE_TTL_MS && chartCache.summary) {
          lastTrendSummary = { ...(chartCache.summary || {}), lineCandidate: chartCache.lineCandidate ?? candidate };
          lastTrendLineCandidate = chartCache.lineCandidate ?? candidate;
          updateTrendTimeline(lastTrendSummary.timeline || []);
          return lastTrendSummary;
        }

        let summary = await fetchTrendSummary(candidate).catch(err => {
          showAppError(`Falha nos gr√°ficos: ${err?.message || err}`);
          return { timeline: [], rows: [], kpi: null };
        });
        let paramsKeyUsed = paramsKey;
        const unfilteredSummary = summary;
        if (selectedCategory && selectedCategory !== CATEGORY_FILTER_ALL) {
          let filtered = filterTrendSummaryByCategory(summary);
          const filteredEmpty = (!filtered.timeline?.length) && (!filtered.rows?.length) && !filtered.kpi;
          const unfilteredHasData = (unfilteredSummary.timeline?.length) || (unfilteredSummary.rows?.length) || unfilteredSummary.kpi;
          if (filteredEmpty && unfilteredHasData) {
            const fallbackParams = { ...params };
            delete fallbackParams.categoria;
            paramsKeyUsed = JSON.stringify(fallbackParams);
            const payloadFallback = await fetchFromEndpoints(CHARTS_ENDPOINTS, fallbackParams).catch(err => {
              console.warn("Falha no fallback dos gr√°ficos por categoria:", err);
              return null;
            });
            filtered = filterTrendSummaryByCategory(normalizeTrendPayload(payloadFallback));
          }
          summary = filtered;
        }
        if (!summary.timeline.length && !summary.rows.length && !summary.kpi) continue;

        chartCache = { paramsKey: paramsKeyUsed, summary, timestamp: now, lineCandidate: candidate };
        lastChartFetchTs = now;
        lastTrendSummary = { ...summary, lineCandidate: candidate };
        lastTrendLineCandidate = candidate;
        updateTrendTimeline(summary.timeline || []);
        await refreshKpis(true);
        found = true;
        return summary;
      }

      // If nothing worked for the current selection (route/category), clear charts instead of keeping stale data.
      chartCache = { paramsKey: "", summary: null, timestamp: 0, lineCandidate: null };
      lastTrendSummary = { timeline: [], kpi: null, rows: [], lineCandidate: null };
      lastTrendLineCandidate = null;
      updateTrendTimeline([]);
      return lastTrendSummary;
    }

    function startChartRefreshLoop() {
      if (chartRefreshIntervalId) return;
      chartRefreshIntervalId = setInterval(() => {
        refreshCharts().catch(err => showAppError(`Falha nos gr√°ficos: ${err?.message || err}`));
      }, CHARTS_REFRESH_INTERVAL_MS);
    }

	    function renderOverlayChart(type) {
      if (!chartOverlayCanvas) return;
      const context = chartOverlayCanvas.getContext("2d");
      if (!context) return;
      if (!trendTimeline.length) {
        if (chartOverlayTitle) chartOverlayTitle.textContent = "Sem dados";
        chartOverlayCanvas.getContext("2d").clearRect(0, 0, chartOverlayCanvas.width, chartOverlayCanvas.height);
        if (chartOverlayExtra) chartOverlayExtra.hidden = true;
        return;
      }
      const labels = trendTimeline.map(entry => timeLabelFormatter.format(entry.interval));
      const data = trendTimeline.map(entry =>
        type === "volume"
          ? Number.isFinite(entry.volume) ? Number(entry.volume.toFixed(0)) : null
          : Number.isFinite(entry.vel15m) ? Number(entry.vel15m.toFixed(1)) : null
      );
	      const color = type === "volume" ? "#f59f00" : "#ff4b4b";
	      const fill = type === "volume" ? "rgba(245, 159, 0, 0.3)" : "transparent";
	      const title = type === "volume" ? "Volume da Frota" : "Velocidade Comercial";
	      const fillMode = type === "volume" ? "start" : false;
	      if (chartOverlayTitle) {
	        let contextLabel = "";
	        if (selectedRoute && selectedRoute !== ROUTE_FILTER_ALL) {
	          const ctx = buildRouteContext();
	          contextLabel = ctx.html || escapeHtml(ctx.text || "");
	        } else if (selectedCategory && selectedCategory !== CATEGORY_FILTER_ALL) {
	          contextLabel = escapeHtml(selectedCategory);
	        } else {
	          contextLabel = "Rede Global";
	        }
	        const safeTitle = escapeHtml(title);
	        chartOverlayTitle.innerHTML = contextLabel
	          ? `<span class=\"chart-overlay-title-main\">${safeTitle}</span><span class=\"chart-overlay-context\">${contextLabel}</span>`
	          : safeTitle;
	      }
	      if (overlayChartInstance) {
	        overlayChartInstance.destroy();
	        overlayChartInstance = null;
	      }
      overlayChartInstance = new Chart(context, {
        type: "line",
        data: {
          labels,
	          datasets: buildSegmentedLineDatasets({
              values: data,
              label: title,
              color,
              fill,
              fillMode,
              borderWidth: 2,
              tension: 0.2
            })
	        },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: "nearest", intersect: false, axis: "x" },
              hover: { mode: "nearest", intersect: false },
              plugins: {
                legend: { display: false },
                tooltip: { mode: "nearest", intersect: false }
              },
              scales: {
                x: {
                  grid: { display: false },
                  ticks: { color: "#0f172a" }
                },
                y: {
                  grid: { color: "rgba(15, 23, 42, 0.1)" },
                  ticks: { color: "#0f172a", beginAtZero: true, padding: 8 },
                  min: 0
                }
              }
            }
      });

      if (type === "volume") {
        renderVolumeOverlayTable().catch(err => console.warn("Falha ao renderizar tabela de ve√≠culos:", err));
      } else if (chartOverlayExtra) {
        chartOverlayExtra.hidden = true;
      }
    }

    function openChartOverlay(type) {
      if (!chartOverlay || !trendTimeline.length) return;
      currentOverlayType = type;
      chartOverlay.classList.add("visible");
      renderOverlayChart(type);
    }

    function closeChartOverlay() {
      if (chartOverlay) chartOverlay.classList.remove("visible");
      currentOverlayType = null;
      if (overlayChartInstance) {
        overlayChartInstance.destroy();
        overlayChartInstance = null;
      }
    }

    if (chartOverlayCanvas && !chartOverlayCanvas.dataset.tooltipClickBound) {
      chartOverlayCanvas.dataset.tooltipClickBound = "1";
      chartOverlayCanvas.addEventListener("click", event => {
        if (!overlayChartInstance || !window.Chart) return;
        const points = overlayChartInstance.getElementsAtEventForMode(
          event,
          "nearest",
          { intersect: false },
          true
        );
        if (!points.length) return;
        const { datasetIndex, index } = points[0];
        const active = [{ datasetIndex, index }];
        overlayChartInstance.setActiveElements(active);
        const pos = window.Chart.helpers?.getRelativePosition
          ? window.Chart.helpers.getRelativePosition(event, overlayChartInstance)
          : null;
        if (overlayChartInstance.tooltip && pos) {
          overlayChartInstance.tooltip.setActiveElements(active, pos);
        }
        overlayChartInstance.update();
      });
    }

    if (chartOverlay) {
      chartOverlay.addEventListener("click", event => {
        if (event.target === chartOverlay) closeChartOverlay();
      });
    }

    if (chartOverlayClose) {
      chartOverlayClose.addEventListener("click", closeChartOverlay);
    }

    document.addEventListener("keydown", event => {
      if (event.key === "Escape") closeChartOverlay();
    });

    if (chartSpeedCard) {
      chartSpeedCard.addEventListener("click", () => openChartOverlay("speed"));
    }
    if (chartVolumeCard) {
      chartVolumeCard.addEventListener("click", () => openChartOverlay("volume"));
    }

    function findCategoryRow(data, category) {
      if (!Array.isArray(data) || data.length === 0) return null;
      if (category && category !== CATEGORY_FILTER_ALL) {
        const match = data.find(item => item.categoria === category);
        if (match) return match;
      }
      return data.find(item => item.categoria === "Global") || data[0];
    }

    function buildUrlWithParams(endpoint, params) {
      try {
        const url = new URL(endpoint);
        // The upstream GTFS-RT endpoint is a raw feed and does not support our filter query params.
        // We fetch the full feed and apply filters client-side.
        if (url.hostname === "rt.jdcp.workers.dev") {
          url.searchParams.set("_ts", String(Date.now()));
          return url.toString();
        }
        Object.entries(params || {}).forEach(([key, value]) => {
          if (value != null && value !== "") {
            url.searchParams.set(key, value);
          }
        });
        return url.toString();
      } catch (err) {
        console.warn("URL inv√°lida ignorada:", endpoint, err);
        return null;
      }
    }

    async function fetchFromEndpoints(endpoints, params = {}, opts = {}) {
      const resolved = (endpoints || [])
        .map(endpoint => buildUrlWithParams(endpoint, params))
        .filter(Boolean);
      if (!resolved.length) throw new Error("Nenhum endpoint v√°lido para chamada.");
      let lastError = null;
      for (const url of resolved) {
        try {
          const response = await fetch(url, { cache: "no-store", signal: opts.signal });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          return await response.json();
        } catch (err) {
          if (opts.signal && opts.signal.aborted) throw err;
          lastError = err;
          console.warn("Falha ao contactar endpoint", url, err);
        }
      }
      throw lastError || new Error("Todos os endpoints falharam");
    }

    async function fetchCategoryKpis(force = false) {
      if (!kpiPanel) return [];
      const now = Date.now();
      if (!force && now - categoryKpisCache.timestamp < KPI_CACHE_TTL_MS) {
        return categoryKpisCache.data || [];
      }
      try {
        const payload = await fetchFromEndpoints(KPI_ENDPOINTS.categories);
        const data = Array.isArray(payload) ? payload : [];
        categoryKpisCache = { timestamp: now, data };
        return data;
      } catch (err) {
        console.warn("Falha ao carregar KPIs de categoria:", err);
        return categoryKpisCache.data || [];
      }
    }

    async function fetchRouteKpi(lineId, force = false) {
      if (!kpiPanel) return null;
      const now = Date.now();
      const key = JSON.stringify({ scope: "route", lineId: lineId || null, categoria: selectedCategory || null });
      if (!force && routeKpisCache.row && routeKpisCache.key === key && (now - routeKpisCache.timestamp) < REFRESH_RATE_MS) {
        return routeKpisCache.row;
      }
      try {
	        if (!lineId) return null;
	        const encoded = encodeURIComponent(String(lineId));
	        const endpoints = KPI_ENDPOINTS.route.map(base => `${base}/${encoded}`);
	        const params = { active_window_min: ACTIVE_WINDOW_MIN };
	        if (selectedCategory && selectedCategory !== CATEGORY_FILTER_ALL) params.categoria = selectedCategory;
	        const payload = await fetchFromEndpoints(endpoints, params);
	        const row = Array.isArray(payload) ? (payload[0] || null) : payload;
	        routeKpisCache = { timestamp: now, key, row };
	        return row;
	      } catch (err) {
	        console.warn("Falha ao carregar KPI da rota (novo endpoint), a tentar legacy:", err);
	        try {
	          const legacyParams = { active_window_min: ACTIVE_WINDOW_MIN };
	          legacyParams.linha = lineId;
	          if (selectedCategory && selectedCategory !== CATEGORY_FILTER_ALL) legacyParams.categoria = selectedCategory;
	          const payload = await fetchFromEndpoints(KPI_ENDPOINTS.routeLegacy, legacyParams);
	          const row = Array.isArray(payload) ? (payload[0] || null) : payload;
	          routeKpisCache = { timestamp: now, key, row };
          return row;
        } catch (legacyErr) {
          console.warn("Falha ao carregar KPI da rota (legacy):", legacyErr);
          return routeKpisCache.row || null;
        }
      }
    }

    async function fetchRouteVariantKpi(variantId, force = false) {
      if (!kpiPanel) return null;
      const now = Date.now();
      const key = JSON.stringify({ scope: "route_variant", variantId: variantId || null, categoria: selectedCategory || null });
      if (!force && routeKpisCache.row && routeKpisCache.key === key && (now - routeKpisCache.timestamp) < REFRESH_RATE_MS) {
        return routeKpisCache.row;
      }
      try {
	        if (!variantId) return null;
	        const encoded = encodeURIComponent(String(variantId));
	        const endpoints = KPI_ENDPOINTS.routeVariant.map(base => `${base}/${encoded}`);
	        const params = { active_window_min: ACTIVE_WINDOW_MIN };
	        if (selectedCategory && selectedCategory !== CATEGORY_FILTER_ALL) params.categoria = selectedCategory;
	        const payload = await fetchFromEndpoints(endpoints, params);
	        const row = Array.isArray(payload) ? (payload[0] || null) : payload;
	        routeKpisCache = { timestamp: now, key, row };
	        return row;
      } catch (err) {
        console.warn("Falha ao carregar KPI da variante:", err);
        return routeKpisCache.row || null;
      }
    }

    async function fetchCategoryKpi(category, force = false) {
      if (!kpiPanel) return null;
      const now = Date.now();
      const key = JSON.stringify({ scope: "category", category: category || null });
      if (!force && routeKpisCache.row && routeKpisCache.key === key && (now - routeKpisCache.timestamp) < KPI_CACHE_TTL_MS) {
        return routeKpisCache.row;
      }
      try {
	        if (!category) return null;
	        const encoded = encodeURIComponent(String(category));
	        const endpoints = KPI_ENDPOINTS.category.map(base => `${base}/${encoded}`);
	        const params = { active_window_min: ACTIVE_WINDOW_MIN };
	        const payload = await fetchFromEndpoints(endpoints, params);
	        const row = Array.isArray(payload) ? (payload[0] || null) : payload;
	        routeKpisCache = { timestamp: now, key, row };
	        return row;
	      } catch (err) {
        console.warn("Falha ao carregar KPI da categoria (novo endpoint):", err);
        return routeKpisCache.row || null;
      }
    }

    function buildRouteContext() {
      const baseLabel = resolvePublicRouteLabel(selectedRoute) || "Carreira";
      let displayLabel = baseLabel;
      let routeIdForPill = selectedRoute;
      if (selectedVariant && selectedVariant !== VARIANT_FILTER_ALL) {
        const variantEntry = routeOptions.get(selectedRoute)?.variants?.get(selectedVariant);
        displayLabel = variantEntry || formatRouteLabel(selectedVariant, baseLabel) || baseLabel;
        routeIdForPill = selectedVariant || selectedRoute;
      }
      const { code } = parseRouteCodeParts(displayLabel || routeIdForPill);
      if (!code) return { text: displayLabel, html: null };
      const style = pillStyleForRoute(displayLabel || routeIdForPill);
      const regex = new RegExp(`^${escapeRegex(code)}\\s*`, "i");
      const rest = (displayLabel || "").replace(regex, "").trim();
      const pillHtml = `<span class="route-pill route-pill--inline" style="--pill-bg:${style.bg};--pill-fg:${style.fg};--pill-border:${style.border}">${escapeHtml(code)}</span>`;
      const html = rest ? `${pillHtml} <span class="route-title-rest">${escapeHtml(rest)}</span>` : pillHtml;
      const text = rest ? `${code} ${rest}` : code;
      return { text, html };
    }

    async function refreshKpis(force = false) {
      if (!kpiPanel) return;
      const routeCandidates = getRouteLineCandidates();
      const computedRow =
        lastTrendSummary?.kpi ||
        computeRouteKpiFromRows(lastTrendSummary?.rows || []);
      if (routeCandidates.length > 0) {
        const contextText = buildRouteContext();
        const hasRouteData = lastTrendLineCandidate != null && routeCandidates.includes(lastTrendLineCandidate);
        // Prefer the new scoped KPI endpoints (variant > route).
        let realtimeKpi = null;
        if (selectedVariant && selectedVariant !== VARIANT_FILTER_ALL) {
          realtimeKpi = await fetchRouteVariantKpi(selectedVariant, force);
        } else {
          realtimeKpi = await fetchRouteKpi(routeCandidates[0], force);
        }
        if (realtimeKpi && computedRow) {
          updateKpiDisplay(
            {
              ...computedRow,
              veiculos_ativos: realtimeKpi.veiculos_ativos ?? computedRow.veiculos_ativos,
              timestamp: realtimeKpi.timestamp ?? computedRow.timestamp,
              vel_comercial: realtimeKpi.vel_comercial ?? computedRow.vel_comercial,
              vel_comercial_1h: realtimeKpi.vel_comercial_1h ?? computedRow.vel_comercial_1h,
              delta_vel_comercial: realtimeKpi.delta_vel_comercial ?? computedRow.delta_vel_comercial
            },
            contextText
          );
          return;
        }
        if (realtimeKpi) {
          updateKpiDisplay(realtimeKpi, contextText);
          return;
        }
        if (hasRouteData && computedRow) {
          updateKpiDisplay(computedRow, contextText);
          return;
        }
      }
      // If no route is selected, prefer the scoped category/global KPI endpoints (more accurate + fresher timestamps).
      if (selectedCategory && selectedCategory !== CATEGORY_FILTER_ALL) {
        const categoryKpi = await fetchCategoryKpi(selectedCategory, force);
        if (categoryKpi) {
          updateKpiDisplay(categoryKpi, buildCategoryContext(selectedCategory) || { text: selectedCategory });
          return;
        }
      } else {
        // "Rede global" should use the global category endpoint, not the chart-derived KPI.
        const globalKpi = await fetchCategoryKpi("global", force);
        if (globalKpi) {
          updateKpiDisplay(globalKpi, buildFloatingContext());
          return;
        }
      }
      if (computedRow) {
        updateKpiDisplay(computedRow, buildFloatingContext());
        return;
      }
      const data = await fetchCategoryKpis(force);
      const row = findCategoryRow(data, selectedCategory);
      updateKpiDisplay(row, buildFloatingContext());
    }

    function handleRouteInputCommit() {
      if (!routeInput) return;
      const focusCleared = routeInput.dataset.focusCleared === "true";
      routeInput.dataset.focusCleared = "false";
      if (routePreview) routePreview.classList.add("hidden");
      const value = routeInput.value || "";
      const trimmedValue = value.trim();
      if (!trimmedValue && focusCleared) {
        const prevRoute = routeInput.dataset.previousRoute || selectedRoute || ROUTE_FILTER_ALL;
        selectedRoute = prevRoute;
        syncRouteInputValue();
        return;
      }
      const resolved = resolveRouteInputValue(value);
      selectedRoute = resolved;
      if (resolved === ROUTE_FILTER_ALL) {
        routeInput.value = ROUTE_GLOBAL_LABEL;
      } else {
        routeInput.value = routeLabelById.get(resolved) || value;
      }
      selectedVariant = VARIANT_FILTER_ALL;
      updateVariantOptions();
      renderVehicles();
      refreshRouteOverlay(true).catch(() => {});
      refreshGlobalStops(true).catch(() => {});
      refreshCharts(true).catch(() => {});
      refreshKpis(true);
      updateRouteClearVisibility();
      renderSelectedRoutePill();
      routeInputWrapper?.classList.remove("input-focused");
    }

    function resolveRouteInputValue(raw) {
      const value = (raw || "").trim();
      if (!value || value.toLowerCase() === ROUTE_GLOBAL_LABEL.toLowerCase()) {
        return ROUTE_FILTER_ALL;
      }
      const lower = value.toLowerCase();
      if (routeLabelLookup.has(lower)) {
        return routeLabelLookup.get(lower);
      }
      if (routeOptions.has(value)) return value;
      for (const [baseId, data] of routeOptions.entries()) {
        const label = (data.label || "").toLowerCase();
        if (label && label === lower) return baseId;
      }
      return ROUTE_FILTER_ALL;
    }

    function syncRouteInputValue() {
      if (!routeInput) return;
      if (selectedRoute === ROUTE_FILTER_ALL) {
        routeInput.value = ROUTE_GLOBAL_LABEL;
      } else {
        routeInput.value = routeLabelById.get(selectedRoute) || selectedRoute;
      }
    }

    function updateVariantOptions() {
      if (!variantSelect || !variantGroup) return;
      variantSelect.innerHTML = "";
      variantSelect.appendChild(new Option("Todas as variantes", VARIANT_FILTER_ALL));
      variantSelect.value = VARIANT_FILTER_ALL;
      if (!selectedRoute || selectedRoute === ROUTE_FILTER_ALL) {
        variantGroup.classList.add("hidden");
        selectedVariant = VARIANT_FILTER_ALL;
        return;
      }
      const entry = routeOptions.get(selectedRoute);
      if (!entry) {
        variantGroup.classList.add("hidden");
        selectedVariant = VARIANT_FILTER_ALL;
        return;
      }
      const variantEntries = entry.variants ? Array.from(entry.variants.entries()) : [];
      if (variantEntries.length === 0) {
        variantGroup.classList.add("hidden");
        selectedVariant = VARIANT_FILTER_ALL;
        return;
      }
      if (variantEntries.length === 1) {
        variantGroup.classList.add("hidden");
        selectedVariant = variantEntries[0][0];
        return;
      }
      variantEntries.sort((a, b) => a[1].localeCompare(b[1], "pt-PT", { numeric: true, sensitivity: "base" }));
      variantEntries.forEach(([value, label]) => {
        variantSelect.appendChild(new Option(label, value));
      });
      const hasSelected = variantEntries.some(([value]) => value === selectedVariant);
      if (hasSelected) {
        variantSelect.value = selectedVariant;
      } else {
        selectedVariant = VARIANT_FILTER_ALL;
        variantSelect.value = VARIANT_FILTER_ALL;
      }
      variantGroup.classList.remove("hidden");
    }

    function normalizeOptionKey(value) {
      return normalizeRouteKey(value);
    }

    function updateRouteOptionsFromVehicles(list) {
      let dirty = false;
      list.forEach(v => {
        const variantId = normalizeOptionKey(v.routeId || v.routeLabel);
        if (!variantId) return;
        const baseId = getBaseRouteKey(variantId);
        if (!baseId) return;
        const routeCategory = v.categoryResolved || v.category;
        if (registerRoute(baseId, variantId, { label: v.routeLabel, category: routeCategory })) dirty = true;
      });
      if (dirty) {
        rebuildRouteSuggestions();
        updateVariantOptions();
        refreshRouteTaxonomy();
      }
    }

    function categoryFromPattern(routeIdOrName, fallbackLabel = "") {
      const label = fallbackLabel || routeIdOrName;
      return definirCategoria(label);
    }

    function routeMatchesSelectedCategory(entry, baseId, labelOverride = "") {
      if (selectedCategory === CATEGORY_FILTER_ALL) return true;
      const label = labelOverride || entry?.label || baseId;
      const category = categoryFromPattern(label || baseId, label);
      return category === selectedCategory;
    }

    function rebuildRouteSuggestions() {
      if (!routeDatalist) return;
      const entries = [];
      routeOptions.forEach((data, baseId) => {
        const label = data.label || baseId;
        if (!routeMatchesSelectedCategory(data, baseId, label)) return;
        const baseLabel = data.label || baseId;
        entries.push({ id: baseId, label: baseLabel });
      });
      const collator = new Intl.Collator("pt-PT", { numeric: true, sensitivity: "base" });
      entries.sort((a, b) => collator.compare(a.label || a.id, b.label || b.id));

      routeDatalist.innerHTML = "";
      routeLabelById.clear();
      routeLabelLookup.clear();
      routeLabelById.set(ROUTE_FILTER_ALL, ROUTE_GLOBAL_LABEL);
      routeLabelLookup.set(ROUTE_GLOBAL_LABEL.toLowerCase(), ROUTE_FILTER_ALL);

      const seenLabels = new Set();
      entries.forEach(({ id, label }) => {
        const text = ((label || id) ?? "").trim();
        if (!text) return;
        const key = text.toLowerCase();
        if (!seenLabels.has(key)) {
          const option = document.createElement("option");
          option.value = text;
          routeDatalist.appendChild(option);
          seenLabels.add(key);
        }
        routeLabelById.set(id, text);
        if (!routeLabelLookup.has(key)) {
          routeLabelLookup.set(key, id);
        }
      });
      if (floatingSearch && floatingSearch.classList.contains("visible")) {
        renderFloatingRoutePreview(floatingRouteInput?.value || "");
      }
      renderRoutePreview(routeInput?.value || "");
    }

    function translateRoute(routeId) {
      const raw = normalizeRouteKey(routeId);
      if (!raw) return "";
      const base = getBaseRouteKey(raw);
      // Only use GTFS metadata/translator for variant-like ids (e.g., 728_0); keep base ids untouched.
      const isVariantId = raw.includes("_");
      if (isVariantId) {
        const metaVariant = raw ? ROUTE_DETAILS.get(raw) : null;
        if (metaVariant?.shortName) return metaVariant.shortName;
        const metaBase = base ? ROUTE_DETAILS.get(`${base}_0`) || BASE_ROUTE_DETAILS.get(base) : null;
        if (metaBase?.shortName) return metaBase.shortName;
        if (ROUTE_TRANSLATOR.byId[raw]) return ROUTE_TRANSLATOR.byId[raw];
        const alt0 = `${base}_0`;
        const alt1 = `${base}_1`;
        if (ROUTE_TRANSLATOR.byId[alt0]) return ROUTE_TRANSLATOR.byId[alt0];
        if (ROUTE_TRANSLATOR.byId[alt1]) return ROUTE_TRANSLATOR.byId[alt1];
        if (ROUTE_TRANSLATOR.base[base]) return ROUTE_TRANSLATOR.base[base];
      }
      return raw;
    }

    function parseRouteCodeParts(routeIdOrName) {
      const rawLabel = String(routeIdOrName ?? "").trim();
      const normalizedInput = normalizeRouteKey(rawLabel);
      // Preferir c√≥digo que apare√ßa no in√≠cio do texto (antes de espa√ßos/pontua√ß√£o) para n√£o capturar letras da descri√ß√£o.
      const leading = rawLabel.match(/^\s*([0-9]{1,3}[A-Z]?)(?=[^0-9A-Z]|$)/i);
      if (leading) {
        const code = leading[1].toUpperCase();
        const digits = code.match(/(\d{1,3})/);
        const codeBase = (/^\d{3}[01]$/.test(code)) ? code.slice(0, 3) : (digits ? digits[1] : code);
        return { code, codeBase };
      }
      // If already parece um c√≥digo curto (ex.: "208", "35B") e sem sufixo, n√£o deixar metadata/tradutor interferir.
      if (normalizedInput && !normalizedInput.includes("_")) {
        const simpleMatch = normalizedInput.match(/^([0-9]{1,3}[A-Z]?)/i);
        if (simpleMatch && simpleMatch[0].length === normalizedInput.length) {
          const code = simpleMatch[1].toUpperCase();
          const digits = code.match(/(\d{1,3})/);
          const codeBase = (code.match(/^\d{3}[01]$/)) ? code.slice(0, 3) : (digits ? digits[1] : code);
          return { code, codeBase };
        }
      }
      const base = getBaseRouteKey(normalizedInput);
      const metaVariant = normalizedInput ? ROUTE_DETAILS.get(normalizedInput) : null;
      const metaBase = base ? BASE_ROUTE_DETAILS.get(base) : null;
      const translated = translateRoute(normalizedInput || base);
      const metaShort = (metaVariant?.shortName || metaBase?.shortName || "").trim();
      const fallback = routeIdOrName != null ? String(routeIdOrName) : "";
      const candidate = (metaShort || translated || fallback).toUpperCase();
      const normalizedCandidate = candidate.replace(/[^A-Z0-9]/g, "");
      const match = normalizedCandidate.match(/(\d{1,3}[A-Z]?)/); // allow codes that are not at the start of the string
      const code = match ? match[1] : normalizedCandidate;
      const codeBase = (() => {
        if (/^\d{3}[01]$/.test(code)) return code.slice(0, 3);
        const digits = code.match(/(\d{1,3})/);
        return digits ? digits[1] : code;
      })();
      return { code, codeBase };
    }

    function careerCodeFromLabel(label) {
      const text = (label || "").trim();
      if (!text) return { code: "", codeBase: "" };
      // Try leading code first (fast path).
      let match = text.match(/^\s*(\d{2,3}[A-Z]?)/);
      if (!match) {
        // Fallback: find the first occurrence anywhere in the string.
        match = text.match(/(\d{2,3}[A-Z]?)/);
      }
      if (!match) return { code: "", codeBase: "" };
      const code = match[1].toUpperCase();
      const digits = code.match(/^\d{2,3}/)?.[0] || code;
      return { code, codeBase: digits };
    }

    function isMadrugadaRoute(routeIdOrName) {
      const raw = normalizeRouteKey(routeIdOrName);
      const resolvedLabel = raw.includes("_") ? (resolvePublicRouteLabel(raw) || raw) : raw;
      const { code, codeBase } = careerCodeFromLabel(resolvedLabel);
      if (!code) return false;
      // Apenas c√≥digos de 3 d√≠gitos come√ßados em 2, sem sufixo E/B e sem underscore.
      const digitsOnly = code.match(/^2\d{2}$/);
      return Boolean(digitsOnly);
    }

    function definirCategoria(routeIdOrName) {
      const raw = normalizeRouteKey(routeIdOrName);
      const resolvedLabel = raw.includes("_") ? (resolvePublicRouteLabel(raw) || raw) : raw;
      const { code, codeBase } = careerCodeFromLabel(resolvedLabel);
      if (code.match(/^2\d{2}$/)) return "Rede Madrugada";
      if (code.endsWith("E")) return "El√©tricos";
      if (code.endsWith("B")) return "Carreiras de Bairro";
      return "Autocarros Diurnos";
    }

    function definirZona(routeIdOrName) {
      const { code, codeBase } = parseRouteCodeParts(routeIdOrName);
      if (!code && !codeBase) return null;
      if (code.endsWith("B")) return "Bairro";
      if (ZONE_ROUTE_BASES.Madrugada.has(codeBase)) return "Madrugada";
      for (const [zone, routes] of Object.entries(ZONE_ROUTE_BASES)) {
        if (routes.has(code) || routes.has(codeBase)) return zone;
      }
      return null;
    }

    function getZoneColor(zoneName) {
      return ZONE_COLOR_BY_NAME[zoneName] || null;
    }

    function vehicleIconMarkup(style) {
      return `<div class="veh-marker" style="--c:${style.color}">
        <div class="veh-pin"></div>
        <i class="fa ${style.icon} veh-icon"></i>
      </div>`;
    }

    function stripRouteCodeFromLabel(label) {
      const text = (label || "").trim();
      if (!text) return "";
      const { code } = parseRouteCodeParts(text);
      if (!code) return text;
      const pattern = new RegExp(`^${escapeRegex(code)}\\s*[-‚Äì‚Äî:]?\\s*`, "i");
      if (!pattern.test(text)) return text;
      const cleaned = text.replace(pattern, "").trim();
      if (!cleaned && text.replace(/\s+/g, "").toUpperCase() === code.toUpperCase()) return "";
      return cleaned || text;
    }

    function popupHtml(v, style) {
      const label = v.routeLabel || v.linha || "‚Äî";
      const dirId = getDirectionId(v);
      const dirLabel = directionDisplayLabel(v?.routeId || v?.linha || "", dirId);
      const { code } = parseRouteCodeParts(label);
      const zoneInfo = resolveRouteZone(label);
      const headerColor = zoneInfo.color || style.color;
      const headerFg = readableTextColor(headerColor, "#ffffff");
      const safeLabel = escapeHtml(label);
      const titleText = stripRouteCodeFromLabel(label);
      const safeTitle = escapeHtml(titleText || "‚Äî");
      const safeDirLabel = dirLabel ? escapeHtml(dirLabel) : "";
      const pill = `<span class="route-pill route-pill--clickable popup-route-link" data-route-label="${safeLabel}" title="Filtrar pela carreira" style="--pill-bg:${headerFg === '#0f172a' ? '#ffffff' : 'rgba(255,255,255,0.14)'};--pill-fg:${headerFg};--pill-border:rgba(255,255,255,0.18)">${escapeHtml(code || label)}</span>`;
      return `
        <div class="pop-header" style="background-color: ${headerColor}; color:${headerFg}">
          <div class="pop-header__left">
            ${pill}
            <span class="pop-title" title="${safeTitle}">${safeTitle}</span>
          </div>
          <div class="pop-header__actions">
            <span style="opacity: 0.8">#${v.id}</span>
          </div>
        </div>
        <div class="pop-body">
          ${safeDirLabel ? `<div style="margin-bottom:4px"><b>${safeDirLabel}</b></div>` : ""}
          <div style="margin-bottom:4px"><b>Velocidade:</b> ${Math.round(v.speed || 0)} km/h</div>
        </div>
      `;
    }

    function normalizeCoordinates(v) {
      const position = v?.position || v?.posicao || {};
      const lat = parseFloat(v.lat ?? v.latitude ?? position.lat ?? position.latitude);
      const lon = parseFloat(v.lon ?? v.longitude ?? position.lon ?? position.longitude);
      if (Number.isFinite(lat) && Number.isFinite(lon)) return [lon, lat];
      return null;
    }

    function clamp01(x) {
      if (!Number.isFinite(x)) return 0;
      if (x < 0) return 0;
      if (x > 1) return 1;
      return x;
    }

    function smoothstep(t) {
      return t * t * (3 - 2 * t);
    }

    function normalizeTimestampSeconds(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return NaN;
      if (num > 1e12) return num / 1000;
      if (num > 1e10) return num / 1000;
      return num;
    }

    function resolveRouteId(vehicle) {
      return vehicle?.routeId ?? vehicle?.route_id ?? vehicle?.route ?? vehicle?.linha ?? vehicle?.line ?? "";
    }

    function decorateVehicle(vehicle) {
      if (!vehicle) return vehicle;
      const enriched = { ...vehicle };
      const routeRaw = normalizeRouteKey(resolveRouteId(vehicle));
      const label = resolvePublicRouteLabel(routeRaw || vehicle.linha);
      const category = definirCategoria(label || routeRaw || vehicle.category);
      enriched.routeId = routeRaw;
      enriched.routeLabel = label || routeRaw;
      enriched.linha = enriched.routeLabel || enriched.linha || "";
      enriched.categoryResolved = category;
      enriched.category = category;
      const zone = definirZona(routeRaw || label || vehicle.zone);
      enriched.zone = zone || "";
      enriched.zoneColor = getZoneColor(zone) || "";
      return enriched;
    }

    function featureToVehicle(feature, index) {
      if (!feature || feature.type !== "Feature") return null;
      const geom = feature.geometry;
      if (!geom) return null;

      let coords = geom.coordinates;
      if (geom.type !== "Point" && Array.isArray(coords) && Array.isArray(coords[0])) coords = coords[0];
      if (!Array.isArray(coords) || coords.length < 2) return null;

      const lat = Number(coords[1]);
      const lon = Number(coords[0]);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;

      const props = feature.properties || {};
      const fallbackId = `offline-${index}`;
      const rawId = props.id_veiculo ?? props.id ?? props.vehicle_id ?? fallbackId;
      const toNumber = (value, fallback = 0) => {
        const num = Number(value);
        return Number.isFinite(num) ? num : fallback;
      };
      const routeId = props.route_id ?? props.route ?? props.linha ?? props.line ?? "";
      const tsValue = props.timestamp ?? props.ts ?? props.time ?? Date.now();
      const directionRaw = props.directionId ?? props.direction_id ?? props.direction ?? props.sentido ?? null;
      const directionId = (() => {
        const parsed = Number.parseInt(String(directionRaw), 10);
        return Number.isFinite(parsed) ? parsed : null;
      })();

      return {
        id: String(rawId),
        lat,
        lon,
        linha: routeId,
        routeId,
        directionId,
        bearing: toNumber(props.heading ?? props.bearing ?? props.azimuth ?? props.course ?? 0, 0),
        speed: toNumber(props.velocidade ?? props.speed ?? props.velocity ?? 0, 0),
        category: props.category ?? props.tipo ?? "",
        ts: tsValue
      };
    }

    async function loadOfflineVehicles() {
      if (offlineVehiclesCache) return offlineVehiclesCache;
      try {
        const response = await fetch(OFFLINE_VEHICLES_URL);
        if (!response.ok) throw new Error("404");
        const data = await response.json();
        const features = Array.isArray(data?.features) ? data.features : [];
        offlineVehiclesCache = features.map(featureToVehicle).filter(Boolean);
      } catch (e) {
        offlineVehiclesCache = VEHICLES_MOCK;
      }
      return offlineVehiclesCache || VEHICLES_MOCK;
    }

    const CATEGORY_PALETTES = {
      // Requested: stronger contrast on Bus + Bairro; keep the same "family" as the Python palette.
      "Autocarros Diurnos": { color0: "#2ecc71", color1: "#0b5d38", icon: "fa-bus" },
      "Carreiras de Bairro": { color0: "#c084fc", color1: "#4c1d95", icon: "fa-home" },
      "El√©tricos": { color0: "#f39c12", color1: "#ff6b6b", icon: "fa-train" },
      "Rede Madrugada": { color0: "#3498db", color1: "#2c3e90", icon: "fa-moon-o" }
    };
    const DEFAULT_CATEGORY_STYLE = CATEGORY_PALETTES["Autocarros Diurnos"];

    const DIRECTION_PALETTE = {
      0: { label: "Sentido 0" },
      1: { label: "Sentido 1" },
      unknown: { label: "Sentido ‚Äî" }
    };

    function inferDirectionFromRouteId(routeId) {
      const raw = (routeId == null) ? "" : String(routeId).trim();
      if (!raw) return null;
      const parts = raw.split("_");
      if (parts.length >= 2) {
        const maybeDir = Number.parseInt(parts[1], 10);
        if (maybeDir === 0 || maybeDir === 1) return maybeDir;
      }
      return null;
    }

    function splitRouteDestinations(longName) {
      const text = (longName || "").trim();
      if (!text) return null;
      const parts = text.split(/\s*[-‚Äì‚Äî]\s*/g).map(s => s.trim()).filter(Boolean);
      if (parts.length >= 2) return [parts[0], parts[1]];
      return null;
    }

    function normalizeDirectionForDisplay(directionId) {
      if (!(directionId === 0 || directionId === 1)) return directionId;
      // Requested: destinations are switched; invert mapping.
      return directionId === 0 ? 1 : 0;
    }

    function directionDisplayLabel(routeId, directionId) {
      if (!(directionId === 0 || directionId === 1)) return "";
      const normalized = normalizeOptionKey(routeId);
      const base = getBaseRouteKey(normalized);
      const meta = (normalized && ROUTE_DETAILS.get(normalized))
        || (base && BASE_ROUTE_DETAILS.get(base))
        || (base && ROUTE_DETAILS.get(`${base}_0`))
        || null;
      const pair = splitRouteDestinations(meta?.longName || "");
      if (!pair) return "Sentido: ‚Äî";
      const idx = normalizeDirectionForDisplay(directionId) === 0 ? 0 : 1;
      const dest = pair[idx];
      const text = (dest || "").trim();
      return `Sentido: ${text || "‚Äî"}`;
    }

    function getDirectionId(vehicle) {
      const raw = vehicle?.directionId ?? vehicle?.direction_id ?? vehicle?.direction;
      const parsed = Number.parseInt(String(raw), 10);
      if (parsed === 0 || parsed === 1) return parsed;
      // Some feeds encode direction in the route id itself (e.g. `170_0` / `170_1`)
      return inferDirectionFromRouteId(vehicle?.routeId ?? vehicle?.linha ?? "");
    }

	    function pickCategoryStyle(category, directionId, { allowDirection = false } = {}) {
	      const palette = CATEGORY_PALETTES[category] || DEFAULT_CATEGORY_STYLE;
	      const effectiveDir = (directionId === 0 || directionId === 1) ? directionId : 0;
	      const dir = allowDirection ? effectiveDir : 0;
	      return {
	        icon: palette.icon,
	        color: (dir === 1 ? (palette.color1 || palette.color0) : palette.color0),
	      };
	    }

    function getStyle(vehicle) {
      const cat = vehicle?.categoryResolved || vehicle?.category;
      const dirId = getDirectionId(vehicle);
      const allowDirection = Boolean(selectedRoute && selectedRoute !== ROUTE_FILTER_ALL);
      return pickCategoryStyle(cat, dirId, { allowDirection });
    }

    // --- LEAFLET ADAPTER ---
    class LeafletAdapter {
      constructor() {
        this.map = L.map('map', { zoomControl: false, preferCanvas: true, inertia: true }).setView(MAP_CENTER, MAP_ZOOM);
        this.markers = new Map();
        this.overlayGroup = L.layerGroup().addTo(this.map);
        this.routeShapesLayer = L.layerGroup().addTo(this.overlayGroup);
        this.routeStopsLayer = L.layerGroup().addTo(this.overlayGroup);
        this.isInteracting = false;
        this.animationDuration = Math.max(300, Math.min(ANIMATION_MS, REFRESH_RATE_MS - 150));
        L.control.zoom({ position: 'topright' }).addTo(this.map);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
          attribution: '&copy; OSM &copy; CARTO',
          subdomains: 'abcd',
          maxZoom: 19,
          detectRetina: true,
          updateWhenIdle: true,
          updateWhenZooming: false,
          keepBuffer: 4
        }).addTo(this.map);

        const startInteraction = () => {
          this.isInteracting = true;
          const container = this.map.getContainer?.();
          if (container) container.classList.add("map-interacting");
          document.body?.classList?.add?.("map-interacting");
          this.clearAllTransitions();
        };
        const endInteraction = () => {
          this.isInteracting = false;
          const container = this.map.getContainer?.();
          if (container) container.classList.remove("map-interacting");
          document.body?.classList?.remove?.("map-interacting");
          // Ensure no lingering transitions after an interaction ends.
          this.clearAllTransitions();
        };
        this.map.on("zoomstart movestart dragstart", startInteraction);
        this.map.on("zoomend moveend dragend", endInteraction);

        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css';
        document.head.appendChild(link);
      }

      clearAllTransitions() {
        for (const entry of this.markers.values()) {
          if (entry?.transitionTimer) {
            clearTimeout(entry.transitionTimer);
            entry.transitionTimer = null;
          }
          const el = entry?.marker?.getElement?.();
          if (el) {
            el.classList.remove("veh-animating");
            el.style.removeProperty("--veh-move-ms");
          }
        }
      }

      slideMarkerTo(entry, lat, lon) {
        if (!entry?.marker) return;
        const marker = entry.marker;
        const el = marker.getElement?.();
        if (!el || this.isInteracting || this.animationDuration <= 0) {
          marker.setLatLng([lat, lon]);
          return;
        }

        if (entry.transitionTimer) {
          clearTimeout(entry.transitionTimer);
          entry.transitionTimer = null;
        }

        el.style.setProperty("--veh-move-ms", `${this.animationDuration}ms`);
        el.classList.add("veh-animating");
        // Defer the position update so the transition can apply.
        requestAnimationFrame(() => marker.setLatLng([lat, lon]));
        entry.transitionTimer = setTimeout(() => {
          const el2 = marker.getElement?.();
          if (el2) {
            el2.classList.remove("veh-animating");
            el2.style.removeProperty("--veh-move-ms");
          }
          entry.transitionTimer = null;
        }, this.animationDuration + 80);
      }

      setShapes(geojson) {
        if (this.shapesLayer) this.map.removeLayer(this.shapesLayer);
        this.shapesLayer = L.geoJSON(geojson || SHAPES_MOCK, {
          style: { color: "#3498db", weight: 4, opacity: 0.5 }
        }).addTo(this.routeShapesLayer);
      }

      clearOverlay() {
        this.routeShapesLayer?.clearLayers?.();
        this.routeStopsLayer?.clearLayers?.();
      }

      setRouteOverlay(payload, { fit = false } = {}) {
        this.clearOverlay();
        if (!payload) return;

        const boundsLayers = [];
        const segments = buildShapeSegments(payload?.shapes);
        const shapes = Array.isArray(payload.shapes) ? payload.shapes : [];
        for (const item of shapes) {
          const geojson = item?.geojson;
          if (!geojson || !geojson.type) continue;
          const color = item?.color || "#3498db";
          const lyr = L.geoJSON(geojson, {
            style: { color, weight: 5, opacity: 0.65 }
          });
          lyr.addTo(this.routeShapesLayer);
          boundsLayers.push(lyr);
        }

        const stops = Array.isArray(payload.stops) ? payload.stops : [];
        for (const s of stops) {
          const lat = Number(s?.stop_lat);
          const lon = Number(s?.stop_lon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
          const arrowColor = s?.color || "#3498db";
          const fallbackAngle = Number(s?.direction_angle);
          const alignedAngle = closestSegmentAngleForPoint(lat, lon, segments, fallbackAngle);
          const iconHtml = `<div class="stop-marker stop--hidden" style="--stop-border:${arrowColor}; --stop-arrow:${arrowColor}; --stop-ang:${alignedAngle}deg"><span class="stop-arrow"></span></div>`;
          const icon = L.divIcon({ html: iconHtml, className: "stop-fade", iconSize: [1, 1], iconAnchor: [0, 0] });
          const stopName = s.stop_name || "Paragem";
          const stopId = s.stop_id || "";
          const marker = L.marker([lat, lon], { icon }).bindPopup(
            stopPopupHtml({ stopName, stopId, loading: true }),
            { maxWidth: 320, className: "custom-popup" }
          );
          marker.on("add", () => {
            const el = marker.getElement?.();
            const inner = el?.querySelector?.(".stop-marker");
            if (!inner) return;
            requestAnimationFrame(() => requestAnimationFrame(() => {
              try { inner.getBoundingClientRect(); } catch (e) {}
              inner.classList.remove("stop--hidden");
              inner.classList.add("stop--shown");
            }));
          });
          marker.on("popupopen", async () => {
            if (!stopId) {
              marker.setPopupContent(stopPopupHtml({ stopName, stopId, routes: [] }));
              try { wireStopPopupPills(marker.getPopup?.().getElement?.()); } catch (e) {}
              return;
            }
            const routes = await ensureStopRoutes(stopId);
            marker.setPopupContent(stopPopupHtml({ stopName, stopId, routes }));
            try { wireStopPopupPills(marker.getPopup?.().getElement?.()); } catch (e) {}
          });
          marker.addTo(this.routeStopsLayer);
          boundsLayers.push(marker);
        }

        if (fit && boundsLayers.length) {
          try {
            const group = L.featureGroup(boundsLayers);
            const bounds = group.getBounds();
            if (bounds && bounds.isValid && bounds.isValid()) {
              this.map.fitBounds(bounds, { padding: [36, 36] });
            }
          } catch (e) {}
        }
      }

      makeDivIcon(style) {
        return L.divIcon({
          html: vehicleIconMarkup(style),
          className: "",
          iconSize: [34, 42],
          iconAnchor: [17, 42],
          popupAnchor: [0, -36]
        });
      }

      applyStyleToMarker(entry, style) {
        if (!entry?.marker || !style) return;
        const el = entry.marker.getElement?.();
        if (!el) return;
        const inner = el.querySelector?.('.veh-marker');
        if (inner) {
          inner.style.setProperty("--c", style.color);
          const icon = inner.querySelector?.('.veh-icon');
          if (icon) icon.className = `fa ${style.icon} veh-icon`;
        }
      }

      updateVehicles(vehicleList) {
        const EPS = 1e-7;
        const activeIDs = new Set();
        vehicleList.forEach(v => {
          if (!v || v.id == null) return;
          const coords = normalizeCoordinates(v);
          if (!coords) return;
          const [lon, lat] = coords;
          const style = getStyle(v);
          const vid = String(v.id);
          activeIDs.add(vid);
          const serverTsSec = normalizeTimestampSeconds(v.ts ?? v.timestamp ?? v.time ?? Date.now());

          let entry = this.markers.get(vid);
          if (!entry) {
            const marker = L.marker([lat, lon], {
              icon: this.makeDivIcon(style),
              riseOnHover: true,
              keyboard: false
            }).addTo(this.map);
            marker.bindPopup(popupHtml(v, style), { className: 'custom-popup' });
            entry = {
              marker,
              styleKey: `${style.color}|${style.icon}`,
              lat,
              lon,
              serverTsSec,
              lastServerTsSec: serverTsSec,
              transitionTimer: null
            };
            this.markers.set(vid, entry);
          } else {
            const prevTs = entry.lastServerTsSec;
            const hasNewTs = Number.isFinite(serverTsSec) && (!Number.isFinite(prevTs) || serverTsSec > prevTs);
            const coordsChanged = !Number.isFinite(entry.lon) || !Number.isFinite(entry.lat) ||
              Math.abs(entry.lon - lon) > EPS || Math.abs(entry.lat - lat) > EPS;
            if (hasNewTs || coordsChanged) {
              entry.lastServerTsSec = serverTsSec;
              entry.serverTsSec = serverTsSec;
              entry.lat = lat;
              entry.lon = lon;
              this.slideMarkerTo(entry, lat, lon);
            }
            const nextStyleKey = `${style.color}|${style.icon}`;
            if (entry.styleKey !== nextStyleKey) {
              entry.styleKey = nextStyleKey;
              this.applyStyleToMarker(entry, style);
              entry.marker.setPopupContent(popupHtml(v, style));
            }
            if (entry.marker.isPopupOpen()) {
              entry.marker.setPopupContent(popupHtml(v, style));
            }
          }
          entry.data = v;
        });

        for (const [vid, entry] of this.markers.entries()) {
          if (!activeIDs.has(vid)) {
            if (entry?.transitionTimer) clearTimeout(entry.transitionTimer);
            entry.marker.remove();
            this.markers.delete(vid);
          }
        }
        return activeIDs.size;
      }

      setVisibleIds(visibleIds) {
        let count = 0;
        for (const [vid, entry] of this.markers.entries()) {
          const el = entry?.marker?.getElement?.();
          if (!el) continue;
          const shouldShow = visibleIds.has(vid);
          el.style.display = shouldShow ? "" : "none";
          if (shouldShow) count += 1;
        }
        return count;
      }
    }

    // --- MAPLIBRE ADAPTER (Principal) ---
    class MapLibreAdapter {
      constructor() {
        this.map = null;
        this.markers = new Map();
        this.isInteracting = false;
        this.animationDuration = Math.max(300, Math.min(ANIMATION_MS, REFRESH_RATE_MS - 150));
        this.visualTickMs = 1000;
        this.visualIntervalId = null;
        this.overlaySourceId = "route-overlay";
        this.overlayReady = false;
        this.routeOverlayFeatures = [];
        this.globalStopFeatures = [];
        this._lastRouteStopsCount = 0;
        this._lastGlobalStopsCount = 0;
        this.activePopups = [];
        this._stopPieCache = new Map();
        this._stopRoutesInflight = new Set();
        this.ready = this.init();
      }

	      async init() {
        this.map = new maplibregl.Map({
          container: "map",
          style: "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json",
          center: [MAP_CENTER[1], MAP_CENTER[0]],
          zoom: MAP_ZOOM,
          attributionControl: false
        });
        this.map.addControl(new maplibregl.NavigationControl({ showCompass: false }), "top-right");
        await new Promise(resolve => this.map.once("load", resolve));
        this.initOverlayLayers();

        const startInteraction = () => {
          this.isInteracting = true;
          const container = this.map.getContainer?.();
          if (container) container.classList.add("map-interacting");
          document.body?.classList?.add?.("map-interacting");
          this.clearAllTransitions();
        };
        const endInteraction = () => {
          this.isInteracting = false;
          const container = this.map.getContainer?.();
          if (container) container.classList.remove("map-interacting");
          document.body?.classList?.remove?.("map-interacting");
          // Ensure no lingering transitions after an interaction ends.
          this.clearAllTransitions();
        };
        this.map.on("zoomstart", startInteraction);
        this.map.on("movestart", startInteraction);
        this.map.on("dragstart", startInteraction);
        this.map.on("zoomend", endInteraction);
        this.map.on("moveend", endInteraction);
        this.map.on("dragend", endInteraction);

        this.visualIntervalId = setInterval(() => this.tickVisuals(), this.visualTickMs);
      }

      ensureStopPieImage(colors) {
        if (!this.map) return null;
        const cols = canonicalPieColors(colors);
        const key = (cols.length ? cols.join("|") : "default");
        const cachedId = this._stopPieCache.get(key);
        if (cachedId && this.map.hasImage(cachedId)) return cachedId;
        const safeKey = key.replace(/[^a-z0-9]+/gi, "-") || "default";
        const id = `stop-pie-${safeKey}`;
        try {
          if (!this.map.hasImage(id)) {
            const canvas = buildPieImage(cols, 44);
            this.map.addImage(id, canvas, { pixelRatio: 2 });
          }
          this._stopPieCache.set(key, id);
          return id;
        } catch (e) {
          return this.map.hasImage("stop-pie-default") ? "stop-pie-default" : null;
        }
      }

	      _applyOverlayData() {
        if (!this.map) return;
        this.initOverlayLayers();
        const src = this.map.getSource(this.overlaySourceId);
        if (!src || typeof src.setData !== "function") return;
        const features = [
          ...(Array.isArray(this.routeOverlayFeatures) ? this.routeOverlayFeatures : []),
          ...(Array.isArray(this.globalStopFeatures) ? this.globalStopFeatures : [])
        ];
	        src.setData({ type: "FeatureCollection", features });
	      }

	      _fadeLayerPaint(layerId, paintProp, targetValue) {
	        if (!this.map) return;
	        try {
	          this.map.setPaintProperty(layerId, paintProp, 0);
	          requestAnimationFrame(() => {
	            try { this.map.setPaintProperty(layerId, paintProp, targetValue); } catch (e2) {}
	          });
	        } catch (e) {}
	      }

      _setLayerPaint(layerId, paintProp, value) {
        if (!this.map) return;
        try { this.map.setPaintProperty(layerId, paintProp, value); } catch (e) {}
      }

      initOverlayLayers() {
        if (!this.map) return;
        this._routeStopsCircleOpacity = 0.98;
        this._routeStopsIconOpacity = 0.95;
        // Use constant opacity so MapLibre transitions reliably animate (we clear global stops below the zoom threshold).
        this._globalStopsCircleOpacity = 0.98;
        this._globalStopsIconOpacity = 0.92;

        const empty = { type: "FeatureCollection", features: [] };
        if (!this.map.getSource(this.overlaySourceId)) {
          this.map.addSource(this.overlaySourceId, { type: "geojson", data: empty });
        }
	        if (!this.map.hasImage?.("stop-triangle")) {
	          const canvas = document.createElement("canvas");
	          canvas.width = 24;
	          canvas.height = 24;
	          const ctx = canvas.getContext("2d");
	          // Up-pointing triangle; MapLibre rotates clockwise (degrees).
	          ctx.fillStyle = "#000";
	          ctx.beginPath();
	          ctx.moveTo(12, 2);
	          ctx.lineTo(18.5, 22);
	          ctx.lineTo(5.5, 22);
	          ctx.closePath();
	          ctx.fill();
	          this.map.addImage("stop-triangle", ctx.getImageData(0, 0, 24, 24), { sdf: true });
	        }
        if (!this.map.getLayer("route-shape")) {
          this.map.addLayer({
            id: "route-shape",
            type: "line",
            source: this.overlaySourceId,
            filter: ["==", ["get", "kind"], "shape"],
            paint: {
              "line-color": ["get", "color"],
              "line-width": 5,
              "line-opacity": 0.65
            }
          });
        }
        if (!this.map.getLayer("route-stops")) {
          this.map.addLayer({
            id: "route-stops",
            type: "circle",
            source: this.overlaySourceId,
            filter: ["==", ["get", "kind"], "stop"],
            paint: {
              "circle-radius": ["interpolate", ["linear"], ["zoom"], 11, 5, 14, 7, 17, 9],
              "circle-color": ["coalesce", ["get", "fill"], "#ffffff"],
              "circle-opacity": this._routeStopsCircleOpacity,
              "circle-stroke-color": ["coalesce", ["get", "border"], "#f1c40f"],
              "circle-stroke-width": ["interpolate", ["linear"], ["zoom"], 11, 2, 14, 2.8, 17, 3.4]
            }
          });
        }
        if (!this.map.getLayer("route-stop-triangles")) {
          this.map.addLayer({
            id: "route-stop-triangles",
            type: "symbol",
            source: this.overlaySourceId,
            filter: ["==", ["get", "kind"], "stop"],
            layout: {
              "icon-image": "stop-triangle",
              "icon-size": ["interpolate", ["linear"], ["zoom"], 11, 0.34, 14, 0.42, 17, 0.5],
              "icon-allow-overlap": true,
              "icon-ignore-placement": true,
              // Our `direction_angle` is degrees from East (0=E, 90=N). The triangle icon points North by default,
              // so rotate by (90 - angle) to align correctly.
              "icon-rotate": ["-", 90, ["coalesce", ["get", "direction_angle"], 0]],
              "icon-rotation-alignment": "map",
              "icon-anchor": "center",
              // Offset the triangle slightly forward (in icon pixels). Note: this offset is in screen space,
              // so keep it subtle; the corrected rotation handles the direction.
              "icon-offset": [0, -1.7]
            },
            paint: {
              "icon-color": ["coalesce", ["get", "arrow"], "#f1c40f"],
              "icon-opacity": this._routeStopsIconOpacity
            }
          });
        }
        if (!this.map.getLayer("global-stops")) {
          this.map.addLayer({
            id: "global-stops",
            type: "circle",
            source: this.overlaySourceId,
            filter: ["==", ["get", "kind"], "global_stop"],
            paint: {
              "circle-radius": ["interpolate", ["linear"], ["zoom"], 10.5, 1.2, 11.5, 2.4, 12.5, 4.8, 15, 8],
              "circle-color": ["coalesce", ["get", "fill"], "#ffffff"],
              "circle-opacity": ["interpolate", ["linear"], ["zoom"], 10.5, 0, 12, 0.08, 13.5, 0.24, 15, 0.4],
              "circle-stroke-color": ["coalesce", ["get", "border"], "#ffd400"],
              "circle-stroke-width": ["interpolate", ["linear"], ["zoom"], 10.5, 0.8, 11.5, 1.4, 12.5, 2.2, 15, 3.1]
            }
          });
        }
        if (!this.map.hasImage("stop-pie-default")) {
          try { this.map.addImage("stop-pie-default", buildPieImage(["#ffd400"], 52), { pixelRatio: 2 }); } catch (e) {}
        }
        if (!this.map.getLayer("global-stops-symbol")) {
          this.map.addLayer({
            id: "global-stops-symbol",
            type: "symbol",
            source: this.overlaySourceId,
            filter: ["==", ["get", "kind"], "global_stop"],
            layout: {
              "icon-image": ["coalesce", ["get", "icon"], "stop-pie-default"],
              "icon-size": ["interpolate", ["linear"], ["zoom"], 10.5, 0.3, 11.5, 0.55, 12.5, 0.85, 15, 1.05],
              "icon-allow-overlap": true,
              "icon-ignore-placement": true,
              "icon-anchor": "center"
            },
            paint: {
              "icon-opacity": ["interpolate", ["linear"], ["zoom"], 10.5, 0, 12, 0.1, 13.5, this._globalStopsCircleOpacity]
            }
          });
        }
        if (!this.map.getLayer("global-stops-triangles")) {
          this.map.addLayer({
            id: "global-stops-triangles",
            type: "symbol",
            source: this.overlaySourceId,
            filter: ["==", ["get", "kind"], "global_stop"],
            layout: {
              "icon-image": "stop-triangle",
              "icon-size": 0.52,
              "icon-allow-overlap": true,
              "icon-ignore-placement": true,
              // Same convention as route stops: degrees from East (0=E, 90=N) -> rotate by (90 - angle)
              "icon-rotate": ["-", 90, ["coalesce", ["get", "direction_angle"], 0]],
              "icon-rotation-alignment": "map",
              "icon-anchor": "center"
            },
            paint: {
              "icon-color": ["coalesce", ["get", "arrow"], "#000000"],
              "icon-opacity": ["interpolate", ["linear"], ["zoom"], 10.5, 0, 12, 0.14, 13.5, this._globalStopsIconOpacity]
            }
          });
        }
        // Route labels above stops are rendered via DOM markers for richer pill styling; keep this layer disabled.
        if (this.map.getLayer("global-stops-routes")) {
          try { this.map.removeLayer("global-stops-routes"); } catch (e) {}
        }

        // Smooth fade when we toggle paint properties (used on data refresh).
        try {
          this.map.setPaintProperty("route-stops", "circle-opacity-transition", { duration: 260, delay: 0 });
          this.map.setPaintProperty("route-stop-triangles", "icon-opacity-transition", { duration: 260, delay: 0 });
          this.map.setPaintProperty("global-stops", "circle-opacity-transition", { duration: 420, delay: 0 });
          this.map.setPaintProperty("global-stops-symbol", "icon-opacity-transition", { duration: 420, delay: 0 });
          this.map.setPaintProperty("global-stops-triangles", "icon-opacity-transition", { duration: 420, delay: 0 });
        } catch (e) {}

        const closeAllPopups = () => {
          const list = Array.isArray(this.activePopups) ? this.activePopups : [];
          list.forEach(p => p?.remove?.());
          this.activePopups = [];
        };

        this.map.on("click", "global-stops", (e) => {
          try {
            const feature = e?.features?.[0];
            if (!feature) return;
            const props = feature.properties || {};
            const stopName = props.stop_name || "Paragem";
            const stopId = props.stop_id || "";
            closeAllPopups();
            const html = stopPopupHtml({ stopName, stopId, loading: true });
            const popup = new maplibregl.Popup({ offset: 12, className: "custom-popup" })
              .setLngLat(e.lngLat)
              .setHTML(html)
              .addTo(this.map);
            this.activePopups.push(popup);
            (async () => {
              try {
                const routes = await ensureStopRoutes(stopId);
                popup.setHTML(stopPopupHtml({ stopName, stopId, routes }));
                try { wireStopPopupPills(popup.getElement?.()); } catch (e3) {}
              } catch (e2) {}
            })();
          } catch (err) {}
        });
        this.map.on("click", "route-stops", (e) => {
          try {
            const feature = e?.features?.[0];
            if (!feature) return;
            const props = feature.properties || {};
            const stopName = props.stop_name || "Paragem";
            const stopId = props.stop_id || "";
            closeAllPopups();
            const popup = new maplibregl.Popup({ offset: 12, className: "custom-popup" })
              .setLngLat(e.lngLat)
              .setHTML(stopPopupHtml({ stopName, stopId, loading: true }))
              .addTo(this.map);
            this.activePopups.push(popup);
            (async () => {
              try {
                const routes = stopId ? await ensureStopRoutes(stopId) : [];
                popup.setHTML(stopPopupHtml({ stopName, stopId, routes }));
                try { wireStopPopupPills(popup.getElement?.()); } catch (e3) {}
              } catch (e2) {}
            })();
          } catch (err) {}
        });
        this.map.on("mouseenter", "route-stops", () => { this.map.getCanvas().style.cursor = "pointer"; });
        this.map.on("mouseleave", "route-stops", () => { this.map.getCanvas().style.cursor = ""; });
        this.map.on("mouseenter", "global-stops", () => { this.map.getCanvas().style.cursor = "pointer"; });
        this.map.on("mouseleave", "global-stops", () => { this.map.getCanvas().style.cursor = ""; });

        this.overlayReady = true;
      }

      clearOverlay() {
        if (!this.map) return;
        this.routeOverlayFeatures = [];
        this.globalStopFeatures = [];
        this._applyOverlayData();
      }

	      setRouteOverlay(payload, { fit = false } = {}) {
	        if (!this.map) return;
	        this.initOverlayLayers();
	        const prevStopCount = this._lastRouteStopsCount || 0;
	        const features = [];
	        const shapes = Array.isArray(payload?.shapes) ? payload.shapes : [];
	        const stops = Array.isArray(payload?.stops) ? payload.stops : [];
	        const segments = buildShapeSegments(shapes);

        for (const item of shapes) {
          const geojson = item?.geojson;
          if (!geojson || !Array.isArray(geojson.features)) continue;
          const color = item?.color || "#3498db";
          for (const f of geojson.features) {
            if (!f || f.type !== "Feature") continue;
            if (f.geometry?.type !== "LineString") continue;
            features.push({
              type: "Feature",
              properties: { ...(f.properties || {}), kind: "shape", color },
              geometry: f.geometry
            });
          }
        }

	        for (const s of stops) {
	          const lat = Number(s?.stop_lat);
	          const lon = Number(s?.stop_lon);
	          if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
	          const color = s?.color || "#3498db";
	          const fallbackAngle = Number(s?.direction_angle);
	          const alignedAngle = closestSegmentAngleForPoint(lat, lon, segments, fallbackAngle);
	          features.push({
	            type: "Feature",
	            properties: {
	              kind: "stop",
              fill: "#ffffff",
              border: color,
              arrow: color,
              stop_id: s?.stop_id || "",
              stop_name: s?.stop_name || "",
              direction_angle: alignedAngle
            },
            geometry: { type: "Point", coordinates: [lon, lat] }
          });
        }

	        this.routeOverlayFeatures = features;
	        this._applyOverlayData();
	        this._lastRouteStopsCount = stops.length;

	        if (prevStopCount === 0 && stops.length > 0) {
	          this._fadeLayerPaint("route-stops", "circle-opacity", Number(this._routeStopsCircleOpacity ?? 0.98));
	          this._fadeLayerPaint("route-stop-triangles", "icon-opacity", Number(this._routeStopsIconOpacity ?? 0.95));
	        }

	        if (fit && features.length) {
	          try {
	            const bounds = new maplibregl.LngLatBounds();
	            for (const f of features) {
              if (f.geometry?.type === "Point") bounds.extend(f.geometry.coordinates);
              if (f.geometry?.type === "LineString") {
                for (const c of f.geometry.coordinates || []) bounds.extend(c);
              }
            }
            if (!bounds.isEmpty()) this.map.fitBounds(bounds, { padding: 40, maxZoom: 15 });
          } catch (e) {}
        }
      }

	      setGlobalStops(payload) {
	        if (!this.map) return;
	        this.initOverlayLayers();
	        const stops = Array.isArray(payload?.stops) ? payload.stops : [];
	        const prevCount = this._lastGlobalStopsCount || 0;
        const preferredAngles = stops.map(s => Number(s?.direction_angle));
        const fallbackAngles = estimateAnglesFromNeighbors(stops, preferredAngles);
        const angleDiff = (a, b) => {
          const da = Math.abs(wrapAngleDeg(a) - wrapAngleDeg(b));
          return Math.min(da, 360 - da);
        };
        const features = [];
        const comboColors = new Map(); // key -> color array
        for (let idx = 0; idx < stops.length; idx++) {
          const s = stops[idx];
          const lat = Number(s?.stop_lat);
          const lon = Number(s?.stop_lon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
          const stopId = (s?.stop_id == null) ? "" : String(s.stop_id);
          const angleRaw = Number(s?.direction_angle);
          const local = Number(fallbackAngles[idx] || 0);
          // Prefer backend-provided tangent; fallback to neighbor estimate only if missing.
          const angle = Number.isFinite(angleRaw) ? angleRaw : local;
          const routes = Array.isArray(s?.routes) ? s.routes : [];
          const routesLabel = routes.map(r => String(r || "").trim()).filter(Boolean).slice(0, 6).join(" ¬∑ ");
          if (stopId && routes.length) stopRoutesCache.set(stopId, routes);
          const finalColors = ["#ffd400"]; // brighter uniform yellow ring
          const comboKey = finalColors.length ? finalColors.join("|") : "default";
          if (!comboColors.has(comboKey)) comboColors.set(comboKey, finalColors);
          const primaryColor = "#ffd400";
          const arrowColor = "#000000";
          features.push({
            type: "Feature",
            properties: {
              kind: "global_stop",
              stop_id: stopId,
              stop_name: s?.stop_name || "",
              direction_angle: Number.isFinite(angle) ? angle : 0,
              routes,
              routes_label: routesLabel,
              colors: finalColors,
              fill: "#ffffff",
              border: primaryColor,
              arrow: arrowColor,
              icon: null, // filled after icons ensured
              iconId: null
            },
            geometry: { type: "Point", coordinates: [lon, lat] }
          });
        }
        // Pre-render one image per color combo and assign icon ids to features.
        const comboToId = new Map();
        for (const [key, colors] of comboColors.entries()) {
          const id = this.ensureStopPieImage(colors) || "stop-pie-default";
          comboToId.set(key, id);
        }
        for (const f of features) {
          const cols = Array.isArray(f.properties?.colors) ? f.properties.colors : [];
          const k = cols.length ? cols.join("|") : "default";
          const imgId = comboToId.get(k) || "stop-pie-default";
          f.properties.icon = imgId;
          f.properties.iconId = imgId;
        }
        const targetCircle = Number(this._globalStopsCircleOpacity ?? 0.98);
        const targetIcon = Number(this._globalStopsIconOpacity ?? 0.92);
        const shouldFadeStops = (prevCount === 0 && features.length > 0) || Math.abs(features.length - prevCount) >= 4;

        this.globalStopFeatures = features;
        this._applyOverlayData();
        this._lastGlobalStopsCount = features.length;

        // Smooth fade in/out on refresh; avoid flashing when only small updates occur.
        if (shouldFadeStops) {
          this._fadeLayerPaint("global-stops", "circle-opacity", targetCircle);
          this._fadeLayerPaint("global-stops-symbol", "icon-opacity", targetCircle);
          this._fadeLayerPaint("global-stops-triangles", "icon-opacity", targetIcon);
        } else {
          this._setLayerPaint("global-stops", "circle-opacity", targetCircle);
          this._setLayerPaint("global-stops-symbol", "icon-opacity", targetCircle);
          this._setLayerPaint("global-stops-triangles", "icon-opacity", targetIcon);
        }
      }

      createMarker(id, coords, style, vehicle, serverTsSec) {
        const wrapper = document.createElement("div");
        wrapper.className = "veh-wrapper";
        wrapper.innerHTML = vehicleIconMarkup(style);
        const inner = wrapper.querySelector('.veh-marker');
        const marker = new maplibregl.Marker({ element: wrapper, anchor: "bottom" })
          .setLngLat(coords)
          .addTo(this.map);
        const popup = new maplibregl.Popup({ offset: 18, className: "custom-popup" }).setHTML(popupHtml(vehicle, style));
        marker.setPopup(popup);
        const state = {
          id,
          marker,
          inner,
          popup,
          lon: coords[0],
          lat: coords[1],
          serverTsSec,
          lastServerTsSec: serverTsSec,
          data: vehicle,
          transitionTimer: null
        };
        this.markers.set(id, state);
        this.applyStyle(state, style);
        this.updateMarkerVisual(state);
        return state;
      }

      clearAllTransitions() {
        for (const state of this.markers.values()) {
          if (state?.transitionTimer) {
            clearTimeout(state.transitionTimer);
            state.transitionTimer = null;
          }
          const el = state?.marker?.getElement?.();
          if (el) {
            el.classList.remove("veh-animating");
            el.style.removeProperty("--veh-move-ms");
          }
        }
      }

      slideMarkerTo(state, coords) {
        const markerEl = state?.marker?.getElement?.();
        if (!markerEl || this.isInteracting || this.animationDuration <= 0) {
          state.marker.setLngLat(coords);
          return;
        }

        if (state.transitionTimer) {
          clearTimeout(state.transitionTimer);
          state.transitionTimer = null;
        }

        markerEl.style.setProperty("--veh-move-ms", `${this.animationDuration}ms`);
        markerEl.classList.add("veh-animating");
        requestAnimationFrame(() => state.marker.setLngLat(coords));
        state.transitionTimer = setTimeout(() => {
          const el2 = state.marker.getElement?.();
          if (el2) {
            el2.classList.remove("veh-animating");
            el2.style.removeProperty("--veh-move-ms");
          }
          state.transitionTimer = null;
        }, this.animationDuration + 80);
      }

      updateMarker(state, coords, style, vehicle, serverTsSec) {
        const EPS = 1e-7;
        const prevTs = state.lastServerTsSec;
        const hasNewTs = Number.isFinite(serverTsSec) && (!Number.isFinite(prevTs) || serverTsSec > prevTs);
        const coordsChanged = !Number.isFinite(state.lon) || !Number.isFinite(state.lat) ||
          Math.abs(state.lon - coords[0]) > EPS || Math.abs(state.lat - coords[1]) > EPS;

        if (hasNewTs || coordsChanged) {
          state.lastServerTsSec = serverTsSec;
          state.lon = coords[0];
          state.lat = coords[1];
          this.slideMarkerTo(state, coords);
        }

        state.serverTsSec = serverTsSec;
        state.data = vehicle;
        this.applyStyle(state, style);
        if (state.popup && typeof state.popup.isOpen === "function" && state.popup.isOpen()) {
          state.popup.setHTML(popupHtml(vehicle, style));
        }
        this.updateMarkerVisual(state, Date.now() / 1000);
      }

      applyStyle(state, style) {
        const inner = state.inner;
        if (!inner) return;
        inner.style.setProperty("--c", style.color);
        const icon = inner.querySelector('.veh-icon');
        if (icon) icon.className = `fa ${style.icon} veh-icon`;
      }

      updateMarkerVisual(state, nowSec = Date.now() / 1000) {
        const inner = state.inner;
        if (!inner) return;
        const pingAge = Number.isFinite(state.serverTsSec) ? nowSec - state.serverTsSec : Infinity;
        const isInactive = pingAge > INACTIVE_SECONDS;
        const isStale = pingAge > ACTIVE_SECONDS && !isInactive;
        inner.classList.toggle("veh--stale", isStale);
        inner.classList.toggle("veh--inactive", isInactive);
      }

      updateVehicles(vehicleList) {
        if (!this.map) return 0;
        const activeIDs = new Set();
        vehicleList.forEach(v => {
          if (!v || v.id == null) return;
          const coords = normalizeCoordinates(v);
          if (!coords) return;
          const style = getStyle(v);
          const vid = String(v.id);
          activeIDs.add(vid);
          const serverTsSec = normalizeTimestampSeconds(v.ts ?? v.timestamp ?? v.time ?? Date.now());
          let state = this.markers.get(vid);
          if (!state) {
            state = this.createMarker(vid, coords, style, v, serverTsSec);
          } else {
            this.updateMarker(state, coords, style, v, serverTsSec);
          }
        });

        for (const [vid, state] of this.markers.entries()) {
          if (!activeIDs.has(vid)) {
            if (state?.transitionTimer) clearTimeout(state.transitionTimer);
            state.marker.remove();
            if (state.popup) state.popup.remove();
            this.markers.delete(vid);
          }
        }
        return activeIDs.size;
      }

      tickVisuals() {
        if (!this.map) return;
        const nowSec = Date.now() / 1000;
        for (const state of this.markers.values()) {
          this.updateMarkerVisual(state, nowSec);
        }
      }

      setVisibleIds(visibleIds) {
        let count = 0;
        for (const [vid, state] of this.markers.entries()) {
          const el = state?.marker?.getElement?.();
          if (!el) continue;
          const shouldShow = visibleIds.has(vid);
          el.style.display = shouldShow ? "" : "none";
          if (shouldShow) count += 1;
        }
        return count;
      }
    }

    // --- Inicializa√ß√£o ---
    function createAdapter() {
      const rendererPref = (urlParams.get('renderer') || "").toLowerCase();
      const hasMapLibre = typeof maplibregl !== "undefined";
      const hasLeaflet = typeof L !== "undefined";

      // Prefer MapLibre (WebGL) for smoother zoom/interaction with many markers.
      if (rendererPref === "leaflet" && hasLeaflet) return new LeafletAdapter();
      if (rendererPref === "maplibre" && hasMapLibre) return new MapLibreAdapter();

      if (hasMapLibre) {
        try {
          return new MapLibreAdapter();
        } catch (err) {
          console.warn("MapLibre falhou, alternando para Leaflet:", err);
        }
      }
      if (hasLeaflet) return new LeafletAdapter();
      throw new Error("Nenhum renderer de mapa dispon√≠vel (MapLibre ou Leaflet).");
    }

	    let adapter;
	    try {
	      adapter = createAdapter();
	    } catch (err) {
	      showAppError(`Falha ao inicializar o mapa: ${err?.message || err}`);
	      adapter = {
	        ready: Promise.resolve(),
	        updateVehicles: () => 0,
	        setVisibleIds: () => 0,
          clearOverlay: () => {},
          setRouteOverlay: () => {}
	      };
	    }

    function clampNumber(v, min, max) {
      const n = Number(v);
      if (!Number.isFinite(n)) return min;
      return Math.min(max, Math.max(min, n));
    }

    function debounce(fn, wait = 160) {
      let t = null;
      return (...args) => {
        if (t) clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

	    function wrapAngleDeg(deg) {
	      const n = Number(deg);
	      if (!Number.isFinite(n)) return 0;
	      let out = n % 360;
	      if (out < 0) out += 360;
	      return out;
	    }

	    // Bearing in degrees from East (0=E, 90=N), matching `direction_angle` convention in this app.
	    function bearingDegFromEast(lat1, lon1, lat2, lon2) {
	      const œÜ1 = (Number(lat1) * Math.PI) / 180;
	      const œÜ2 = (Number(lat2) * Math.PI) / 180;
	      const ŒîŒª = ((Number(lon2) - Number(lon1)) * Math.PI) / 180;
	      const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
	      const x = Math.cos(œÜ1) * Math.sin(œÜ2) - Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
	      // `atan2(y, x)` gives bearing from North (clockwise). Convert to "from East" convention.
	      const bearingFromNorth = Math.atan2(y, x) * (180 / Math.PI); // -180..180
	      const bearingFromEast = 90 - bearingFromNorth;
	      return wrapAngleDeg(bearingFromEast);
	    }

    function estimateAnglesFromNeighbors(stops, preferredAngles = null) {
      const list = Array.isArray(stops) ? stops : [];
	      const pts = [];
	      for (let i = 0; i < list.length; i++) {
	        const s = list[i];
	        const lat = Number(s?.stop_lat);
	        const lon = Number(s?.stop_lon);
	        if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
	        pts.push({ i, lat, lon });
	      }
	      const out = new Array(list.length).fill(0);
	      if (pts.length < 2) return out;

	      const R = 6371000;
	      const K = 8;
	      const MAX_D_M = 260;
	      const MAX_D2 = MAX_D_M * MAX_D_M;
	      const preferred = Array.isArray(preferredAngles) ? preferredAngles : null;

	      const angleDiff = (a, b) => {
	        const da = Math.abs(wrapAngleDeg(a) - wrapAngleDeg(b));
	        return Math.min(da, 360 - da);
	      };

	      for (const p of pts) {
	        const refLat = (p.lat * Math.PI) / 180;
	        const cosRef = Math.cos(refLat);
	        const px = ((p.lon * Math.PI) / 180) * cosRef * R;
	        const py = ((p.lat * Math.PI) / 180) * R;
	        const neigh = [];
	        for (const q of pts) {
	          if (q.i === p.i) continue;
	          const qx = ((q.lon * Math.PI) / 180) * cosRef * R;
	          const qy = ((q.lat * Math.PI) / 180) * R;
	          const dx = qx - px;
	          const dy = qy - py;
	          const d2 = dx * dx + dy * dy;
	          if (d2 <= MAX_D2) neigh.push({ q, dx, dy, d2 });
	        }
	        if (neigh.length === 0) continue;
	        neigh.sort((a, b) => a.d2 - b.d2);
		        const use = neigh.slice(0, K);

		        if (use.length === 1) {
		          out[p.i] = bearingDegFromEast(p.lat, p.lon, use[0].q.lat, use[0].q.lon);
		          continue;
		        }

	        let sxx = 0, syy = 0, sxy = 0;
	        for (const n of use) {
	          const dx = n.dx;
	          const dy = n.dy;
	          sxx += dx * dx;
	          syy += dy * dy;
	          sxy += dx * dy;
	        }
	        // Principal axis angle relative to x-axis (East), sign-ambiguous.
	        const theta = 0.5 * Math.atan2(2 * sxy, (sxx - syy));
	        const axisDeg = wrapAngleDeg(theta * (180 / Math.PI));
	        const axisDegOpp = wrapAngleDeg(axisDeg + 180);

	        const nearestBearing = bearingDegFromEast(p.lat, p.lon, use[0].q.lat, use[0].q.lon);
	        const want = Number.isFinite(Number(preferred?.[p.i])) ? Number(preferred[p.i]) : nearestBearing;
        out[p.i] = (angleDiff(axisDegOpp, want) < angleDiff(axisDeg, want)) ? axisDegOpp : axisDeg;
      }
      return out;
    }

    function uniqueZoneColorsFromRoutes(routes) {
      const colors = [];
      const seen = new Set();
      const list = Array.isArray(routes) ? routes : [];
      list.forEach(rRaw => {
        const r = (rRaw == null) ? "" : String(rRaw).trim();
        if (!r) return;
        const zone = definirZona(r);
        const color = zone ? getZoneColor(zone) : null;
        if (color && !seen.has(color)) {
          seen.add(color);
          colors.push(color);
        }
      });
      return colors;
    }

    function canonicalPieColors(colors) {
      const seen = new Set();
      const list = Array.isArray(colors) ? colors : [];
      const deduped = [];
      for (const raw of list) {
        const c = (raw == null) ? "" : String(raw).trim();
        if (!c) continue;
        const key = c.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        deduped.push(c);
      }
      return deduped.sort();
    }

    function parseStopColors(value) {
      if (Array.isArray(value)) return value;
      if (typeof value === "string") {
        try {
          const parsed = JSON.parse(value);
          if (Array.isArray(parsed)) return parsed;
        } catch (e) {}
      }
      return [];
    }

    const ROUTE_PIE_COLORS = [
      "#e74c3c", "#f39c12", "#f1c40f", "#2ecc71", "#1abc9c", "#16a085",
      "#3498db", "#9b59b6", "#8e44ad", "#e67e22", "#d35400", "#34495e",
      "#ff6b6b", "#1dd1a1", "#48dbfb", "#5f27cd"
    ];

    function hashString(str) {
      let h = 0;
      const s = String(str || "");
      for (let i = 0; i < s.length; i++) {
        h = ((h << 5) - h) + s.charCodeAt(i);
        h |= 0;
      }
      return h >>> 0;
    }

    function colorForRouteLabel(label) {
      const key = (label == null) ? "" : String(label).trim().toLowerCase();
      if (!key) return CATEGORY_PALETTES["Autocarros Diurnos"].color0;
      const idx = hashString(key) % ROUTE_PIE_COLORS.length;
      return ROUTE_PIE_COLORS[idx];
    }

    // Route colors are derived from zone colors instead of per-route hashes for stop pies.

    function buildPieImage(colors, size = 44) {
      const cols = Array.isArray(colors) && colors.length ? colors : ["#f1c40f"];
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      const cx = size / 2;
      const cy = size / 2;
      const radius = size / 2 - 1;
      const innerR = radius * 0.52;
      const slice = (Math.PI * 2) / cols.length;
      let start = -Math.PI / 2;
      cols.forEach((c) => {
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.fillStyle = c;
        ctx.arc(cx, cy, radius, start, start + slice);
        ctx.closePath();
        ctx.fill();
        start += slice;
      });
      // Punch a hole for the arrow to sit cleanly.
      ctx.save();
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(cx, cy, innerR, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      // Outer stroke for crisp edges.
      ctx.beginPath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.arc(cx, cy, radius - 0.5, 0, Math.PI * 2);
      ctx.stroke();
      return canvas;
    }

	    function buildShapeSegments(shapes) {
	      const segments = [];
	      const list = Array.isArray(shapes) ? shapes : [];
	      for (const item of list) {
	        const geojson = item?.geojson;
	        const feats = Array.isArray(geojson?.features) ? geojson.features : [];
	        for (const f of feats) {
	          if (f?.geometry?.type !== "LineString") continue;
	          const coords = Array.isArray(f.geometry.coordinates) ? f.geometry.coordinates : [];
	          for (let i = 1; i < coords.length; i++) {
	            const a = coords[i - 1];
	            const b = coords[i];
	            if (!Array.isArray(a) || !Array.isArray(b)) continue;
	            const lon1 = Number(a[0]), lat1 = Number(a[1]);
	            const lon2 = Number(b[0]), lat2 = Number(b[1]);
	            if (!Number.isFinite(lon1) || !Number.isFinite(lat1) || !Number.isFinite(lon2) || !Number.isFinite(lat2)) continue;
	            segments.push({ lon1, lat1, lon2, lat2 });
	          }
	        }
	      }
	      return segments;
	    }

	    function closestSegmentAngleForPoint(lat, lon, segments, fallbackAngleDeg) {
	      const segs = Array.isArray(segments) ? segments : [];
	      if (!segs.length) return Number.isFinite(Number(fallbackAngleDeg)) ? Number(fallbackAngleDeg) : 0;

	      const R = 6371000;
	      const refLat = (Number(lat) * Math.PI) / 180;
	      const cosRef = Math.cos(refLat);
	      const px = ((Number(lon) * Math.PI) / 180) * cosRef * R;
	      const py = ((Number(lat) * Math.PI) / 180) * R;

	      let best = null;
	      let bestD2 = Infinity;
	      for (const s of segs) {
	        const ax = ((s.lon1 * Math.PI) / 180) * cosRef * R;
	        const ay = ((s.lat1 * Math.PI) / 180) * R;
	        const bx = ((s.lon2 * Math.PI) / 180) * cosRef * R;
	        const by = ((s.lat2 * Math.PI) / 180) * R;
	        const abx = bx - ax;
	        const aby = by - ay;
	        const apx = px - ax;
	        const apy = py - ay;
	        const denom = abx * abx + aby * aby;
	        if (denom <= 1e-12) continue;
	        const t = clampNumber((apx * abx + apy * aby) / denom, 0, 1);
	        const cx = ax + abx * t;
	        const cy = ay + aby * t;
	        const dx = px - cx;
	        const dy = py - cy;
	        const d2 = dx * dx + dy * dy;
	        if (d2 < bestD2) {
	          bestD2 = d2;
	          best = s;
	        }
	      }

	      if (!best) return Number.isFinite(Number(fallbackAngleDeg)) ? Number(fallbackAngleDeg) : 0;

	      const a = bearingDegFromEast(best.lat1, best.lon1, best.lat2, best.lon2);
	      const b = wrapAngleDeg(a + 180);
	      const fallback = wrapAngleDeg(Number.isFinite(Number(fallbackAngleDeg)) ? Number(fallbackAngleDeg) : 0);
	      const da = Math.min(Math.abs(a - fallback), 360 - Math.abs(a - fallback));
	      const db = Math.min(Math.abs(b - fallback), 360 - Math.abs(b - fallback));
	      return (db < da) ? b : a;
	    }

	    async function wireMapEvents() {
	      try {
	        if (adapter.ready instanceof Promise) await adapter.ready;
	        if (!adapter?.map) return;
	        const applyStopMarkerSize = () => {
	          try {
	            const z = Number(adapter.map.getZoom?.());
            const px = stopPixelSizeForZoom(z);
            document.documentElement.style.setProperty("--map-zoom-size", `${px}px`);
          } catch (e) {}
        };
	        // Leaflet supports multiple events in a single string; MapLibre doesn't.
	        if (adapter instanceof LeafletAdapter) {
	          const handleStopsUpdate = () => scheduleRefreshStops(false);
	          adapter.map.on("zoomend", () => {
	            handleStopsUpdate();
	            applyStopMarkerSize();
	          });
	          adapter.map.on("moveend", handleStopsUpdate);
	          adapter.map.on("movestart", cancelGlobalStopsFetch);
	          adapter.map.on("zoomstart", cancelGlobalStopsFetch);
	          applyStopMarkerSize();
	        } else if (adapter instanceof MapLibreAdapter) {
	          const handleStopsUpdate = () => scheduleRefreshStops(false);
	          adapter.map.on("zoomend", () => {
	            handleStopsUpdate();
	            applyStopMarkerSize();
	            updateMapLibreStopLabels();
	          });
	          adapter.map.on("moveend", () => {
	            handleStopsUpdate();
	            updateMapLibreStopLabels();
	          });
	          adapter.map.on("movestart", cancelGlobalStopsFetch);
	          adapter.map.on("zoomstart", cancelGlobalStopsFetch);
	          applyStopMarkerSize();
	          updateMapLibreStopLabels();
	        }
	      } catch (err) {}
	    }

	    const OVERLAY_CACHE_TTL_MS = 5 * 60_000;
	    const OVERLAY_DIRECTIONS = [0, 1];
	    const overlayCache = new Map(); // key -> { ts, payload }
	    let currentOverlayKey = null;
	    let currentOverlayFitKey = null;
	    let overlayInflight = null;

    // Stop marker tuning: LOD threshold and transition timing (CSS uses ~260ms).
    const STOPS_MIN_ZOOM = 13;
    const STOP_ANIMATION_MS = 320;
    const STOP_REMOVE_DELAY_MS = STOP_ANIMATION_MS + 80;
    const GLOBAL_STOPS_LIMIT = 1200;
    const GLOBAL_STOPS_LIMIT_MIN = 600;
    const GLOBAL_STOPS_KEY_PRECISION = 1e4;
    const GLOBAL_STOPS_CACHE_TTL_MS = 120_000;
	    const globalStopsCache = new Map(); // key -> { ts, payload }
    let globalStopsAbort = null;
    let globalStopsKey = null;
    let lastRenderedGlobalStopsKey = null;
    const renderedStopsMap = new Map(); // stopKey -> { marker, lat, lon, angleDeg }
    const mapLibreStopLabelMarkers = new Map();
    const STOP_LABEL_ZOOM_THRESHOLD = 15.2; // Zoom onde as pills come√ßam a aparecer
    const STOP_LABEL_FADE_MS = 260;
    let mapLibreStopsFadeTimer = null;



    function stopPixelSizeForZoom(z) {
      if (!Number.isFinite(z)) return 9;
      const t = Math.max(0, z - STOPS_MIN_ZOOM);
      const px = Math.round(4 + t * 3.8);
      return Math.max(4, Math.min(32, px));
    }

    function roundBoundsForStops(bounds, factor = GLOBAL_STOPS_KEY_PRECISION) {
      if (!bounds) return null;
      const round = (n) => Math.round(Number(n) * factor) / factor;
      return {
        minLat: round(bounds.minLat),
        minLon: round(bounds.minLon),
        maxLat: round(bounds.maxLat),
        maxLon: round(bounds.maxLon)
      };
    }

    function dynamicGlobalStopsLimit(z) {
      const minZ = STOPS_MIN_ZOOM;
      const maxZ = minZ + 4; // scale up over ~4 zoom levels
      const t = clampNumber((Number(z) - minZ) / (maxZ - minZ), 0, 1);
      const val = GLOBAL_STOPS_LIMIT_MIN + t * (GLOBAL_STOPS_LIMIT - GLOBAL_STOPS_LIMIT_MIN);
      return Math.round(val);
    }

    function stopKeyForStop(s) {
      const stopId = (s?.stop_id || "").trim();
      if (stopId) return `id:${stopId}`;
      const lat = Number(s?.stop_lat);
      const lon = Number(s?.stop_lon);
      if (Number.isFinite(lat) && Number.isFinite(lon)) return `c:${lat.toFixed(6)},${lon.toFixed(6)}`;
      return null;
    }

    function stopLabelPillsHtml() { return ""; }

    function resetMapLibreStopOpacity() {
      if (!(adapter instanceof MapLibreAdapter) || !adapter.map) return;
      const map = adapter.map;
      const circle = Number(adapter._globalStopsCircleOpacity ?? 0.98);
      const icon = Number(adapter._globalStopsIconOpacity ?? 0.92);
      try { map.setPaintProperty("global-stops", "circle-opacity", circle); } catch (e) {}
      try { map.setPaintProperty("global-stops-symbol", "icon-opacity", circle); } catch (e) {}
      try { map.setPaintProperty("global-stops-triangles", "icon-opacity", icon); } catch (e) {}
    }

    function fadeOutMapLibreStops() {
      if (!(adapter instanceof MapLibreAdapter) || !adapter.map) return;
      const map = adapter.map;
      if (mapLibreStopsFadeTimer) {
        clearTimeout(mapLibreStopsFadeTimer);
        mapLibreStopsFadeTimer = null;
      }
      try { map.setPaintProperty("global-stops", "circle-opacity", 0); } catch (e) {}
      try { map.setPaintProperty("global-stops-symbol", "icon-opacity", 0); } catch (e) {}
      try { map.setPaintProperty("global-stops-triangles", "icon-opacity", 0); } catch (e) {}
      mapLibreStopsFadeTimer = setTimeout(() => {
        try { adapter.setGlobalStops({ stops: [] }); } catch (e) {}
        clearMapLibreStopLabels();
        mapLibreStopsFadeTimer = null;
      }, STOP_REMOVE_DELAY_MS + 40);
    }

    function clearMapLibreStopLabels() {
      for (const marker of mapLibreStopLabelMarkers.values()) {
        try {
          const el = marker.getElement?.();
          if (el) {
            el.classList.remove("stop-label--shown");
            el.classList.add("stop-label--hidden");
          }
          setTimeout(() => {
            try { marker.remove?.(); } catch (e) {}
          }, STOP_LABEL_FADE_MS + 40);
        } catch (e) {}
      }
      mapLibreStopLabelMarkers.clear();
    }

    function updateMapLibreStopLabels() {
      const m = (adapter instanceof MapLibreAdapter) ? adapter.map : (adapter?.getMap?.());
      if (!m || !(adapter instanceof MapLibreAdapter)) return;
      const zoom = Number(m.getZoom?.());

      if (!Number.isFinite(zoom) || zoom < STOP_LABEL_ZOOM_THRESHOLD) {
        clearMapLibreStopLabels();
        return;
      }

      const features = m.queryRenderedFeatures?.({ layers: ["global-stops"] }) || [];
      const currentIds = new Set();

      features.forEach(f => {
        const stopId = f?.properties?.stop_id;
        if (!stopId) return;
        currentIds.add(stopId);

        if (!mapLibreStopLabelMarkers.has(stopId)) {
          const container = document.createElement("div");
          container.className = "stop-label-container stop-label--hidden";

          const marker = new maplibregl.Marker({
            element: container,
            anchor: "bottom",
            offset: [0, -10]
          })
            .setLngLat(f.geometry?.coordinates || [0, 0])
            .addTo(m);

          mapLibreStopLabelMarkers.set(stopId, marker);
          requestAnimationFrame(() => {
            container.classList.remove("stop-label--hidden");
            container.classList.add("stop-label--shown");
          });
          renderStopPillsAsync(stopId, container);
        } else {
          const el = mapLibreStopLabelMarkers.get(stopId)?.getElement?.();
          if (el) {
            el.classList.remove("stop-label--hidden");
            el.classList.add("stop-label--shown");
          }
        }
      });

      for (const [id, marker] of mapLibreStopLabelMarkers.entries()) {
        if (!currentIds.has(id)) {
          const el = marker.getElement?.();
          if (el) {
            el.classList.remove("stop-label--shown");
            el.classList.add("stop-label--hidden");
          }
          setTimeout(() => {
            try { marker.remove(); } catch (e) {}
            mapLibreStopLabelMarkers.delete(id);
          }, STOP_LABEL_FADE_MS + 40);
        }
      }
    }

    async function renderStopPillsAsync(stopId, container) {
      try {
        const routes = await ensureStopRoutes(stopId);
        if (!routes || routes.length === 0 || !container) return;
        const displayRoutes = routes;
        const pillsHtml = displayRoutes.map(routeLabel => {
          const { code } = parseRouteCodeParts(routeLabel);
          const style = pillStyleForRoute(routeLabel);
          const bg = style?.bg || "#444";
          const fg = style?.fg || "#fff";
          const border = style?.border || "rgba(0,0,0,0.2)";
          return `<span class="stop-label-pill-mini" style="background-color:${bg}; color:${fg}; border-color:${border}">${code}</span>`;
        }).join("");
        container.innerHTML = `<div class="stop-label-pills">${pillsHtml}</div>`;
        const pillsEl = container.querySelector?.(".stop-label-pills");
        if (pillsEl) {
          requestAnimationFrame(() => pillsEl.classList.add("stop-label-pills--visible"));
        }
      } catch (err) {
        console.warn("Erro ao carregar rotas para pill:", stopId);
      }
    }

    function cancelGlobalStopsFetch() {
      if (globalStopsAbort) {
        try { globalStopsAbort.abort(); } catch (e) {}
        globalStopsAbort = null;
      }
    }

    const scheduleRefreshStops = (() => {
      const debounced = debounce((force = false) => refreshGlobalStops(force).catch(() => {}), 220);
      return (force = false) => {
        cancelGlobalStopsFetch();
        debounced(force);
      };
    })();

    wireMapEvents().catch(() => {});

    function activeVariantIdsForSelectedRoute() {
      if (!selectedRoute || selectedRoute === ROUTE_FILTER_ALL) return [];
      const out = new Set();
      const list = Array.isArray(lastVehicles) ? lastVehicles : [];
      for (const v of list) {
        const variantKey = normalizeOptionKey(v?.routeId || v?.routeLabel);
        if (!variantKey) continue;
        const baseKey = getBaseRouteKey(variantKey);
        if (baseKey && baseKey === selectedRoute) out.add(variantKey);
      }
      // If the feed didn't give us any active variants, fallback to what we know from the catalog.
      if (out.size === 0) {
        const entry = routeOptions.get(selectedRoute);
        const variants = entry?.variants ? Array.from(entry.variants.keys()) : [];
        variants.forEach(v => out.add(normalizeOptionKey(v)));
      }
      return Array.from(out).filter(Boolean).sort();
    }

    function resolveOverlayVariantIds() {
      if (!selectedRoute || selectedRoute === ROUTE_FILTER_ALL) return [];
      if (selectedVariant && selectedVariant !== VARIANT_FILTER_ALL) return [normalizeOptionKey(selectedVariant)];
      // "Todas as variantes": render every variant that currently has active vehicles.
      return activeVariantIdsForSelectedRoute();
    }

    function shapeEndpoints(routeId) {
      const encoded = encodeURIComponent(String(routeId || ""));
      return (LOCAL_BACKENDS || []).map(base => `${base}/api/shapes/${encoded}`);
    }

    function routeCategoryForId(routeId) {
      const normalized = normalizeOptionKey(routeId);
      const base = getBaseRouteKey(normalized);
      const displayLabel = resolvePublicRouteLabel(normalized);
      const category = definirCategoria(displayLabel || normalized || base);
      const baseCategory = definirCategoria(base || normalized);
      // If short name exists, trust it first; only fall back to base category when we couldn't classify.
      return category || baseCategory;
    }

    function routeDirectionColor(routeId, directionId) {
      const category = routeCategoryForId(routeId);
      const style = pickCategoryStyle(category, directionId, { allowDirection: true });
      return style.color;
    }

	    function serverDirectionForClientDirection(directionId) {
	      // Use the same direction id for both vehicles and overlays.
	      return directionId;
	    }

    function stopsEndpoints(routeId) {
      const encoded = encodeURIComponent(String(routeId || ""));
      return (LOCAL_BACKENDS || []).map(base => `${base}/api/stops/${encoded}`);
    }

    function routeDetailEndpoints(routeId, dateStr) {
      const encoded = encodeURIComponent(String(routeId || ""));
      const day = dateStr || new Date().toISOString().split("T")[0];
      return CHARTS_DETAIL_ENDPOINTS.map(base => `${base}?date=${encodeURIComponent(day)}&line_id=${encoded}`);
    }

    async function fetchRouteOverlayPayload(routeIds) {
      const now = Date.now();
      const ids = Array.isArray(routeIds) ? routeIds.filter(Boolean) : [];
      const cacheKey = JSON.stringify({ ids });
      const cached = overlayCache.get(cacheKey);
      if (cached && (now - cached.ts) < OVERLAY_CACHE_TTL_MS) return cached.payload;

      const shapes = [];
      const stops = [];
      const seenStops = new Set();

      for (const routeId of ids) {
        for (const dirId of OVERLAY_DIRECTIONS) {
          const color = routeDirectionColor(routeId, dirId);
          try {
            const geojson = await fetchFromEndpoints(shapeEndpoints(routeId), { direction: String(serverDirectionForClientDirection(dirId)) });
            if (geojson && geojson.type) {
              shapes.push({ routeId, directionId: dirId, color, geojson });
            }
          } catch (err) {}

          try {
            const rows = await fetchFromEndpoints(stopsEndpoints(routeId), { direction: String(serverDirectionForClientDirection(dirId)), limit: "220" });
            const list = Array.isArray(rows) ? rows : [];
            for (const s of list) {
              const key = `${s?.stop_id || ""}|${Number(s?.stop_lat).toFixed(6)}|${Number(s?.stop_lon).toFixed(6)}|${dirId}|${routeId}`;
              if (seenStops.has(key)) continue;
              seenStops.add(key);
              stops.push({ ...s, routeId, directionId: dirId, color });
            }
          } catch (err) {}
        }
      }

      const payload = { routeIds: ids, shapes, stops };
      overlayCache.set(cacheKey, { ts: now, payload });
      return payload;
    }

    async function refreshRouteOverlay(force = false) {
      const ids = resolveOverlayVariantIds();
      const wantKey = ids.length ? JSON.stringify(ids) : null;

      if (!wantKey) {
        if (currentOverlayKey) {
          currentOverlayKey = null;
          currentOverlayFitKey = null;
          adapter?.clearOverlay?.();
        }
        return;
      }

      if (!force && currentOverlayKey === wantKey) return;
      currentOverlayKey = wantKey;

      // Prevent overlapping refreshes for rapid filter changes.
      if (overlayInflight) return;
      overlayInflight = (async () => {
        try {
          if (adapter.ready instanceof Promise) await adapter.ready;
          const payload = await fetchRouteOverlayPayload(ids);
          const shouldFit = currentOverlayFitKey !== wantKey;
          adapter?.setRouteOverlay?.(payload, { fit: shouldFit });
          if (shouldFit) currentOverlayFitKey = wantKey;
        } catch (err) {
          console.warn("Falha ao carregar overlay de rota:", err);
        } finally {
          overlayInflight = null;
        }
      })();
    }

    function stopsBboxEndpoints() {
      return (LOCAL_BACKENDS || []).map(base => `${base}/api/stops_bbox`);
    }

    function stopRoutesEndpoints(stopId) {
      const encoded = encodeURIComponent(String(stopId || ""));
      return (LOCAL_BACKENDS || []).map(base => `${base}/api/stop_routes/${encoded}`);
    }

    const stopRoutesCache = new Map(); // stop_id -> [routeShortNames]
    const stopRoutesInflight = new Map(); // stop_id -> Promise

    async function ensureStopRoutes(stopId) {
      const key = String(stopId || "");
      if (!key) return [];
      if (stopRoutesCache.has(key)) return stopRoutesCache.get(key) || [];
      const inflight = stopRoutesInflight.get(key);
      if (inflight) return inflight;
      const promise = (async () => {
        try {
          const payload = await fetchFromEndpoints(stopRoutesEndpoints(key), {});
          const routes = Array.isArray(payload?.routes) ? payload.routes : [];
          stopRoutesCache.set(key, routes);
          return routes;
        } catch (err) {
          return [];
        } finally {
          stopRoutesInflight.delete(key);
        }
      })();
      stopRoutesInflight.set(key, promise);
      return promise;
    }

    function escapeHtml(value) {
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function escapeRegex(value) {
      return String(value ?? "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function pillBgForCategory(category) {
      if (category === "Autocarros Diurnos") return "#2ecc71";
      if (category === "Carreiras de Bairro") return "#c084fc";
      if (category === "El√©tricos") return "#f39c12";
      if (category === "Rede Madrugada") return "#3498db";
      return "#e2e8f0";
    }

    function resolveRouteZone(label) {
      const zone = definirZona(label);
      const color = getZoneColor(zone);
      return { zone: zone || null, color: color || null };
    }

    function readableTextColor(bg, fallback = "#ffffff") {
      if (!bg || typeof bg !== "string") return fallback;
      const hex = bg.replace("#", "").trim();
      if (hex.length !== 6) return fallback;
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      if ([r, g, b].some(v => Number.isNaN(v))) return fallback;
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.65 ? "#0f172a" : "#ffffff";
    }

    function pillStyleForRoute(label) {
      const { zone, color } = resolveRouteZone(label);
      const cat = categoryForRouteLabel(label) || definirCategoria(label);
      const bg = color || pillBgForCategory(cat);
      const fg = color ? "#ffffff" : "#0b1220";
      const border = color || "rgba(15, 23, 42, 0.12)";
      const title = zone || cat || "Carreira";
      return { bg, fg, border, title, zone };
    }

    function categoryForRouteLabel(label) {
      const text = (label || "").trim();
      if (!text) return null;
      // Use displayed label; do not trust internal ids.
      return definirCategoria(text);
    }

	    function routePillsHtml(routes) {
	      const list = Array.isArray(routes) ? routes : [];
	      if (!list.length) {
	        return `<span class="route-pill" style="--pill-bg:#e2e8f0">‚Äî</span>`;
	      }
	      return list.map(r => {
	        const label = (r == null) ? "" : String(r).trim();
	        if (!label) return "";
	        const style = pillStyleForRoute(label);
	        const safeLabel = escapeHtml(label);
	        const safeTitle = escapeHtml(style.title || label);
	        return `<span class="route-pill route-pill--clickable" style="--pill-bg:${style.bg};--pill-fg:${style.fg};--pill-border:${style.border}" title="${safeTitle}" role="button" tabindex="0" data-route-label="${safeLabel}">${safeLabel}</span>`;
	      }).filter(Boolean).join("");
	    }

    function stopPopupHtml({ stopName, stopId, routes, loading = false } = {}) {
      const title = (stopName || "Paragem").trim();
      const meta = (stopId || "").trim();
      const pills = loading
        ? `<span class="route-pill route-pill--loading">a carregar‚Ä¶</span>`
        : routePillsHtml(routes);
      return `
        <div class="stop-popup">
          <div class="stop-popup__title">${title}</div>
          <div class="stop-popup__meta">${meta}</div>
          <div class="stop-popup__section">Carreiras</div>
          <div class="pill-row">${pills}</div>
        </div>
      `;
    }

    function resolveBaseIdFromLabel(label) {
      const normalized = (label || "").trim();
      if (!normalized) return null;
      const { code } = parseRouteCodeParts(normalized);
      if (code) {
        const upperCode = code.toUpperCase();
        for (const [baseId, data] of routeOptions.entries()) {
          const entryLabel = data?.label || baseId;
          const entryCode = parseRouteCodeParts(entryLabel).code;
          if (entryCode && entryCode.toUpperCase() === upperCode) {
            return baseId;
          }
        }
      }
      return baseIdForPublicRouteLabel(normalized) || resolveRouteInputValue(normalized);
    }

    function baseIdForPublicRouteLabel(label) {
      const needle = (label || "").trim().toLowerCase();
      if (!needle) return null;

      // 1) Exact match against the translator base map (fast).
      for (const [baseId, shortName] of Object.entries(ROUTE_TRANSLATOR.base || {})) {
        if (!shortName) continue;
        if (String(shortName).trim().toLowerCase() === needle) return String(baseId);
      }

      // 2) Match against loaded GTFS route short names.
      for (const [routeId, meta] of ROUTE_DETAILS.entries()) {
        const shortName = (meta?.shortName || "").trim().toLowerCase();
        if (shortName && shortName === needle) return getBaseRouteKey(routeId);
      }

      return null;
    }

    function applyRouteSelection(baseId) {
      if (!baseId) return;
      selectedRoute = String(baseId);
      selectedVariant = VARIANT_FILTER_ALL;
      updateVariantOptions();
      syncRouteInputValue();
      updateRouteClearVisibility();
      renderSelectedRoutePill();
      if (routePreview) {
        routePreview.classList.add("hidden");
        routePreview.innerHTML = "";
      }
      routeInputWrapper?.classList.remove("input-focused");
      routeInputWrapper?.classList.add("pill-visible");
      renderVehicles();
      refreshRouteOverlay(true).catch(() => {});
      refreshGlobalStops(true).catch(() => {});
      refreshCharts(true).catch(() => {});
      refreshKpis(true);
      setSidebarCollapsed(true);
    }

    function handlePopupRouteActions() {
      document.addEventListener("click", (event) => {
        const link = event.target.closest(".popup-route-link");
        if (link) {
          event.preventDefault();
          const label = link.dataset.routeLabel || link.textContent || "";
          const baseId = resolveBaseIdFromLabel(label);
          if (baseId && baseId !== ROUTE_FILTER_ALL) applyRouteSelection(baseId);
          return;
        }
      });
    }

    function closeFloatingSearch() {
      if (floatingSearch) {
        floatingSearch.classList.add("hidden");
        floatingSearch.classList.remove("visible");
      }
      if (floatingRoutePreview) floatingRoutePreview.innerHTML = "";
    }

    function renderFloatingRoutePreview(query) {
      if (!floatingRoutePreview) return;
      const entries = previewEntries(query);
      if (!entries.length) {
        floatingRoutePreview.innerHTML = `<div class="preview-item" aria-hidden="true"><span class="preview-label">Sem resultados</span></div>`;
        return;
      }
      const html = entries.map(({ id, label }) => {
        const displayLabel = label || id;
        const style = pillStyleForRoute(displayLabel);
        const { code } = parseRouteCodeParts(displayLabel);
        const pillText = code || displayLabel || id;
        const regex = code ? new RegExp(`^${escapeRegex(code)}\\s*`, "i") : null;
        const restLabel = regex ? (displayLabel.replace(regex, "").trim() || displayLabel) : displayLabel;
        const safeLabel = escapeHtml(restLabel);
        const safeId = escapeHtml(id);
        const pill = `<span class="route-pill" aria-hidden="true" style="--pill-bg:${style.bg};--pill-fg:${style.fg};--pill-border:${style.border}">${escapeHtml(pillText)}</span>`;
        return `<div class="preview-item" role="option" data-route-id="${safeId}">
          <span class="preview-label">${pill} ${safeLabel}</span>
        </div>`;
      }).join("");
      floatingRoutePreview.innerHTML = html;
      Array.from(floatingRoutePreview.querySelectorAll(".preview-item")).forEach(item => {
        if (item.dataset.bound === "1") return;
        item.dataset.bound = "1";
        item.addEventListener("mousedown", (ev) => {
          ev.preventDefault();
          const rid = item.dataset.routeId || "";
          if (rid) applyRouteSelection(rid);
          closeFloatingSearch();
        });
      });
    }

    function openFloatingSearch() {
      if (!floatingSearch || !floatingRouteInput) return;
      floatingSearch.classList.remove("hidden");
      floatingSearch.classList.add("visible");
      if (!selectedRoute || selectedRoute === ROUTE_FILTER_ALL) {
        floatingRouteInput.value = "";
      } else {
        floatingRouteInput.value = routeLabelById.get(selectedRoute) || resolvePublicRouteLabel(selectedRoute) || "";
      }
      renderFloatingRoutePreview(floatingRouteInput.value || "");
      try { floatingRouteInput.focus({ preventScroll: true }); } catch (e) { floatingRouteInput.focus(); }
      floatingRouteInput.select();
    }

    function handleFloatingRouteCommit() {
      if (!floatingRouteInput) return;
      const value = floatingRouteInput.value || "";
      const resolved = resolveRouteInputValue(value);
      if (resolved === ROUTE_FILTER_ALL) {
        clearRouteSelection();
      } else if (resolved) {
        applyRouteSelection(resolved);
      }
      closeFloatingSearch();
    }

    function wireFloatingContextActions() {
      if (kpiFloatingChip) {
        kpiFloatingChip.addEventListener("click", (ev) => {
          if (ev.target.closest("#kpi-floating-clear")) return;
          ev.preventDefault();
          focusRouteSearchFromFloating();
        });
        kpiFloatingChip.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter" || ev.key === " ") {
            ev.preventDefault();
            focusRouteSearchFromFloating();
          }
        });
      }
      if (kpiFloatingClear) {
        kpiFloatingClear.addEventListener("click", (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          resetFiltersToGlobal();
        });
      }
    }

    function clearRouteSelection() {
      selectedRoute = ROUTE_FILTER_ALL;
      selectedVariant = VARIANT_FILTER_ALL;
      syncRouteInputValue();
      updateVariantOptions();
      renderVehicles();
      refreshRouteOverlay(true).catch(() => {});
      refreshGlobalStops(true).catch(() => {});
      refreshCharts(true).catch(() => {});
      refreshKpis(true);
      updateRouteClearVisibility();
      renderSelectedRoutePill();
      closeFloatingSearch();
    }

	    function wireStopPopupPills(containerEl) {
	      if (!containerEl) return;
	      const pills = Array.from(containerEl.querySelectorAll?.(".route-pill[data-route-label]") || []);
	      pills.forEach(pill => {
        if (pill.dataset.bound === "1") return;
        pill.dataset.bound = "1";
        const activate = () => {
          const label = pill.dataset.routeLabel || pill.textContent || "";
          const baseId = resolveBaseIdFromLabel(label);
          if (baseId && baseId !== ROUTE_FILTER_ALL) applyRouteSelection(baseId);
        };
        pill.addEventListener("click", (ev) => { ev.preventDefault(); ev.stopPropagation(); activate(); });
        pill.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter" || ev.key === " ") {
            ev.preventDefault();
            activate();
          }
        });
      });
    }

    function adapterZoom() {
      if (!adapter?.map || typeof adapter.map.getZoom !== "function") return NaN;
      try {
        return Number(adapter.map.getZoom());
      } catch (e) {
        return NaN;
      }
    }

    function adapterBounds() {
      if (!adapter?.map) return null;
      try {
        // Leaflet: LatLngBounds with getSouthWest/getNorthEast
        if (typeof adapter.map.getBounds === "function") {
          const b = adapter.map.getBounds();
          const sw = b.getSouthWest?.();
          const ne = b.getNorthEast?.();
          if (sw && ne) {
            return { minLat: sw.lat, minLon: sw.lng, maxLat: ne.lat, maxLon: ne.lng };
          }
        }
        // MapLibre: LngLatBounds with getSouthWest/getNorthEast
        if (typeof adapter.map.getBounds === "function") {
          const b = adapter.map.getBounds();
          const sw = b.getSouthWest?.();
          const ne = b.getNorthEast?.();
          if (sw && ne) {
            return { minLat: sw.lat, minLon: sw.lng, maxLat: ne.lat, maxLon: ne.lng };
          }
        }
      } catch (e) {}
      return null;
    }

    function ensureLeafletGlobalStopsLayer() {
      if (!(adapter instanceof LeafletAdapter)) return;
      if (!adapter.globalStopsLayer) {
        adapter.globalStopsLayer = L.layerGroup().addTo(adapter.overlayGroup);
      }
    }

    function fadeOutLeafletLayer(layerGroup, ms = STOP_REMOVE_DELAY_MS) {
      if (!layerGroup || typeof layerGroup.getLayers !== "function") return;
      if (adapter instanceof LeafletAdapter && adapter.globalStopsLayer === layerGroup) {
        renderedStopsMap.clear();
      }
      const layers = layerGroup.getLayers();
      const timeoutMs = Math.max(50, Number.isFinite(ms) ? ms : STOP_REMOVE_DELAY_MS);
      layers.forEach(layer => {
        const el = layer?.getElement?.();
        const inner = el?.querySelector?.(".stop-marker");
        if (inner) {
          inner.classList.remove("stop--shown");
          inner.classList.add("stop--hidden");
        }
        setTimeout(() => {
          try { layerGroup.removeLayer(layer); } catch (e) {}
        }, timeoutMs);
      });
    }

    function renderGlobalStops(payload) {
      if (!payload) return;
      const stops = Array.isArray(payload.stops) ? payload.stops : [];
      const zoom = adapterZoom();
      const belowLod = !Number.isFinite(zoom) || zoom < STOPS_MIN_ZOOM;

      if (adapter instanceof LeafletAdapter) {
        if (belowLod) {
          if (adapter.globalStopsLayer) fadeOutLeafletLayer(adapter.globalStopsLayer);
          return;
        }
        ensureLeafletGlobalStopsLayer();
        const nextKeys = new Set();
        const preferredAngles = stops.map(s => Number(s?.direction_angle));
        const fallbackAngles = estimateAnglesFromNeighbors(stops, preferredAngles);
        const angleDiff = (a, b) => {
          const da = Math.abs(wrapAngleDeg(a) - wrapAngleDeg(b));
          return Math.min(da, 360 - da);
        };

        for (let idx = 0; idx < stops.length; idx++) {
          const s = stops[idx];
          const lat = Number(s?.stop_lat);
          const lon = Number(s?.stop_lon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
          const stopId = (s?.stop_id || "").trim();
          const routes = (Array.isArray(s?.routes) ? s.routes : []);
          if (stopId && routes.length) stopRoutesCache.set(stopId, routes);
          const primaryColor = "#ffd400";
          const arrowColor = "#000000";
          const key = stopKeyForStop(s);
          if (!key) continue;
          nextKeys.add(key);

          const angleRaw = Number(s?.direction_angle);
          const local = Number(fallbackAngles[idx] || 0);
          // Prefer payload (backend shape tangent); fallback to neighbor estimate only if missing.
          const angleDeg = Number.isFinite(angleRaw) ? angleRaw : local;
          const angCss = Number.isFinite(angleDeg) ? `${angleDeg}deg` : "0deg";
          const existing = renderedStopsMap.get(key);

          if (!existing) {
            const iconHtml = `<div class="stop-marker stop--hidden" style="--stop-border:${primaryColor}; --stop-arrow:${arrowColor}; --stop-ang:${angCss}; background:#ffffff"><span class="stop-arrow"></span></div>`;
            const icon = L.divIcon({ html: iconHtml, className: "stop-fade", iconSize: [1, 1], iconAnchor: [0, 0] });
            const marker = L.marker([lat, lon], { icon });
            marker.addTo(adapter.globalStopsLayer);

            marker.bindPopup(
              stopPopupHtml({ stopName: (s.stop_name || "Paragem"), stopId: (s.stop_id || ""), loading: true }),
              { maxWidth: 320, className: "custom-popup" }
            );

            marker.on("popupopen", async () => {
              const stopId = s?.stop_id || "";
              const routes = await ensureStopRoutes(stopId);
              marker.setPopupContent(stopPopupHtml({ stopName: (s.stop_name || "Paragem"), stopId, routes }));
              try { wireStopPopupPills(marker.getPopup?.().getElement?.()); } catch (e) {}
            });

            marker.on("add", () => {
              const el = marker.getElement?.();
              if (!el) return;
              const inner = el.querySelector?.(".stop-marker");
              if (!inner) return;
              requestAnimationFrame(() => requestAnimationFrame(() => {
                try { inner.getBoundingClientRect(); } catch (e) {}
                inner.classList.remove("stop--hidden");
                inner.classList.add("stop--shown");
              }));
            });

            renderedStopsMap.set(key, { marker, lat, lon, angleDeg: Number.isFinite(angleDeg) ? angleDeg : 0 });
            continue;
          }

          if (Math.abs(existing.lat - lat) > 1e-8 || Math.abs(existing.lon - lon) > 1e-8) {
            existing.marker.setLatLng([lat, lon]);
            existing.lat = lat;
            existing.lon = lon;
          }

          const nextAngle = Number.isFinite(angleDeg) ? angleDeg : 0;
          if (existing.angleDeg !== nextAngle) {
            const el = existing.marker.getElement?.();
            const inner = el?.querySelector?.(".stop-marker");
            if (inner) inner.style.setProperty("--stop-ang", `${nextAngle}deg`);
            existing.angleDeg = nextAngle;
          }
          // No labels to update
        }

        for (const [key, entry] of renderedStopsMap.entries()) {
          if (nextKeys.has(key)) continue;
          const el = entry?.marker?.getElement?.();
          const inner = el?.querySelector?.(".stop-marker");
          if (inner) {
            inner.classList.remove("stop--shown");
            inner.classList.add("stop--hidden");
          }
          setTimeout(() => {
            try { adapter.globalStopsLayer.removeLayer(entry.marker); } catch (e) {}
          }, STOP_REMOVE_DELAY_MS);
          renderedStopsMap.delete(key);
        }
        return;
      }

      if (adapter instanceof MapLibreAdapter) {
        if (belowLod) {
          fadeOutMapLibreStops();
          return;
        }
        if (mapLibreStopsFadeTimer) {
          clearTimeout(mapLibreStopsFadeTimer);
          mapLibreStopsFadeTimer = null;
        }
        adapter.setGlobalStops(payload);
        resetMapLibreStopOpacity();
      }
    }

    async function refreshGlobalStops(force = false) {
      if (!adapter) return;
      if (!force && adapter?.isInteracting) return;
      if (selectedRoute !== ROUTE_FILTER_ALL) {
        // Clear when leaving global mode
        cancelGlobalStopsFetch();
        if (adapter instanceof LeafletAdapter && adapter.globalStopsLayer) fadeOutLeafletLayer(adapter.globalStopsLayer);
        if (adapter instanceof MapLibreAdapter) adapter.setGlobalStops({ stops: [] });
        if (adapter instanceof MapLibreAdapter) clearMapLibreStopLabels();
        globalStopsKey = null;
        lastRenderedGlobalStopsKey = null;
        return;
      }

      const z = adapterZoom();
      if (!Number.isFinite(z) || z < STOPS_MIN_ZOOM) {
        cancelGlobalStopsFetch();
        if (adapter instanceof LeafletAdapter && adapter.globalStopsLayer) fadeOutLeafletLayer(adapter.globalStopsLayer);
        if (adapter instanceof MapLibreAdapter) {
          // remove global stops by re-rendering empty list
          renderGlobalStops({ stops: [] });
        }
        if (adapter instanceof MapLibreAdapter) clearMapLibreStopLabels();
        globalStopsKey = null;
        lastRenderedGlobalStopsKey = null;
        return;
      }

      const b = adapterBounds();
      if (!b) return;
      const roundedBounds = roundBoundsForStops(b, GLOBAL_STOPS_KEY_PRECISION);
      const effLimit = dynamicGlobalStopsLimit(z);
      const key = JSON.stringify({ ...(roundedBounds || {}), z: Math.round(z * 10) / 10, limit: effLimit });
      const sameViewport = globalStopsKey === key;
      globalStopsKey = key;

      const now = Date.now();
      const cached = globalStopsCache.get(key);
      const cachedFresh = cached && (now - cached.ts) < GLOBAL_STOPS_CACHE_TTL_MS;
      if (!force && cachedFresh) {
        if (lastRenderedGlobalStopsKey !== key) renderGlobalStops(cached.payload);
        lastRenderedGlobalStopsKey = key;
        return;
      }
      if (!force && sameViewport && globalStopsAbort) return;

      cancelGlobalStopsFetch();
      const controller = new AbortController();
      globalStopsAbort = controller;
      (async () => {
        try {
          if (adapter.ready instanceof Promise) await adapter.ready;
          const payload = await fetchFromEndpoints(stopsBboxEndpoints(), {
            min_lat: String(b.minLat),
            max_lat: String(b.maxLat),
            min_lon: String(b.minLon),
            max_lon: String(b.maxLon),
            limit: String(effLimit),
            include_routes: "1"
          }, { signal: controller.signal });
          const stops = Array.isArray(payload) ? payload : (payload?.stops || []);
          const data = { stops };
          globalStopsCache.set(key, { ts: now, payload: data });
          renderGlobalStops(data);
          lastRenderedGlobalStopsKey = key;
        } catch (err) {
          if (controller.signal.aborted) return;
          console.warn("Falha ao carregar paragens (rede global):", err);
          if (cached?.payload) {
            renderGlobalStops(cached.payload);
            lastRenderedGlobalStopsKey = key;
          }
        } finally {
          if (globalStopsAbort === controller) globalStopsAbort = null;
        }
      })();
    }

    function filterVehicles(list) {
      return list.filter(v => {
        if (selectedCategory !== CATEGORY_FILTER_ALL) {
          const resolved = v.categoryResolved || v.category || "";
          if (resolved !== selectedCategory) return false;
        }
        if (selectedRoute !== ROUTE_FILTER_ALL) {
          const variantKey = normalizeOptionKey(v.routeId || v.routeLabel);
          const baseKey = getBaseRouteKey(variantKey);
          if (selectedVariant !== VARIANT_FILTER_ALL) {
            if (!variantKey || variantKey !== selectedVariant) return false;
          } else if (!baseKey || (baseKey !== selectedRoute && variantKey !== selectedRoute)) {
            return false;
          }
        }
        return true;
      });
    }

    function updateStatus(state) {
      if (!statusDot) return;
      statusDot.className = `status-dot ${state}`;
    }

    async function renderVehicles() {
      const baseList = Array.isArray(lastVehicles) ? lastVehicles : [];
      if (adapter.ready instanceof Promise) await adapter.ready;
      // Keep markers for the full feed so switching filters is instant (show/hide instead of destroy/recreate).
      adapter.updateVehicles(baseList);
      const filtered = filterVehicles(baseList);
      const visibleIds = new Set(filtered.map(v => String(v.id)));
      const visibleCount = typeof adapter.setVisibleIds === "function"
        ? adapter.setVisibleIds(visibleIds)
        : filtered.length;
      return visibleCount;
    }

    function normalizeVehicles(data) {
       let list = [];
       if (Array.isArray(data)) list = data;
       else if (data?.features) list = data.features;
       else if (data?.entity) list = data.entity;

       const normalized = list.map((item, idx) => {
          if (item && item.vehicle) {
            const veh = item.vehicle;
            const vehInfo = veh.vehicle || {};
            const pos = veh.position || {};
            const trip = veh.trip || {};
            const speedMs = Number(pos.speed);
            return {
              id: vehInfo.id ?? vehInfo.label ?? `gtfs-${idx}`,
              lat: pos.latitude,
              lon: pos.longitude,
              routeId: trip.routeId ?? trip.tripId ?? "",
              linha: trip.routeId ?? "",
              directionId: trip.directionId ?? trip.direction_id ?? null,
              bearing: pos.bearing ?? pos.heading ?? pos.course ?? null,
              speed: Number.isFinite(speedMs) ? speedMs * 3.6 : 0,
              ts: veh.timestamp ?? pos.timestamp ?? Date.now()
            };
          }
          if (item?.type === "Feature") return featureToVehicle(item, idx);
          return item;
       }).filter(v => v && v.lat);
       return normalized.map(decorateVehicle);
    }

    async function fetchData() {
      updateStatus("fetching");
      const vehicleParams = buildVehicleQueryParams();
      try {
        const payload = await fetchFromEndpoints(VEHICLE_ENDPOINTS, vehicleParams);
        const vehicles = normalizeVehicles(payload);
        lastVehicles = vehicles;
        updateRouteOptionsFromVehicles(vehicles);
        await renderVehicles();
        refreshRouteOverlay(false).catch(() => {});
        refreshGlobalStops(false).catch(() => {});
        updateStatus("online");
        refreshKpis().catch(() => {});
        clearAppError();
      } catch (err) {
        console.warn("Offline mode:", err);
        showAppError(`Falha a obter ve√≠culos: ${err?.message || err}`);
        const fallback = await loadOfflineVehicles();
        const vehicles = normalizeVehicles(fallback);
        lastVehicles = vehicles;
        updateRouteOptionsFromVehicles(vehicles);
        await renderVehicles();
        refreshRouteOverlay(false).catch(() => {});
        refreshGlobalStops(false).catch(() => {});
        updateStatus("offline");
        refreshKpis().catch(() => {});
      }
    }

    function startPolling() {
      let timerId = null;
      const loop = async () => {
        const started = performance.now();
        await fetchData();
        const elapsed = performance.now() - started;
        const delay = Math.max(0, REFRESH_RATE_MS - elapsed);
        timerId = setTimeout(loop, delay);
      };
      if (timerId) clearTimeout(timerId);
      loop();
    }

    function startKpiRefreshLoop() {
      setInterval(() => {
        // Force refresh to bypass caches so KPIs update even if other polling loops are quiet.
        refreshKpis(true).catch(() => {});
      }, KPI_REFRESH_INTERVAL_MS);
    }

	    setSidebarCollapsed(window.matchMedia && window.matchMedia("(max-width: 900px)").matches);
	    initCategoryFilter();
	    initRouteFilter();
	    initFloatingSearch();
	    wireFloatingContextActions();
    initVariantFilter();
    initPreviewCharts();

(async () => {
      await checkApiHealth().catch(() => {});
      await Promise.allSettled([loadRouteTranslator(), loadRoutesCatalog()]);
      await refreshCharts(true).catch(() => {});
      startChartRefreshLoop();
      startKpiRefreshLoop();
      startPolling();
      handlePopupRouteActions();
    })();

  </script>
</body>
</html>
